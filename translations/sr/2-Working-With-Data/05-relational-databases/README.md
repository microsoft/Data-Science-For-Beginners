<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80d80300002ef4e77cc7631d5904bd6e",
  "translation_date": "2025-10-25T19:08:10+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "sr"
}
-->
# Рад са подацима: Релационе базе података

|![ Скетчнота од [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| Рад са подацима: Релационе базе података - _Скетчнота од [@nitya](https://twitter.com/nitya)_ |

Вероватно сте раније користили табелу за чување информација. Имали сте скуп редова и колона, где су редови садржали информације (или податке), а колоне описивале те информације (понекад назване метаподаци). Релациона база података је изграђена на овом основном принципу колона и редова у табелама, што вам омогућава да имате информације распоређене у више табела. Ово вам омогућава да радите са сложенијим подацима, избегнете дуплирање и имате флексибилност у начину истраживања података. Хајде да истражимо концепте релационе базе података.

## [Квиз пре предавања](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## Све почиње са табелама

У основи релационе базе података налазе се табеле. Као и код табела, табела је збирка колона и редова. Ред садржи податке или информације са којима желимо да радимо, као што су име града или количина падавина. Колоне описују податке које чувају.

Хајде да започнемо истраживање тако што ћемо направити табелу за чување информација о градовима. Можемо почети са њиховим именом и државом. Ово можете сачувати у табели као што је приказано:

| Град     | Држава        |
| -------- | ------------- |
| Токио    | Јапан         |
| Атланта  | Сједињене Државе |
| Окланд   | Нови Зеланд   |

Приметите да називи колона **град**, **држава** и **популација** описују податке који се чувају, а сваки ред садржи информације о једном граду.

## Недостаци приступа са једном табелом

Вероватно вам горња табела изгледа прилично познато. Хајде да додамо неке додатне податке у нашу растућу базу података - годишње падавине (у милиметрима). Фокусираћемо се на године 2018, 2019 и 2020. Ако бисмо их додали за Токио, то би изгледало овако:

| Град  | Држава | Година | Количина |
| ----- | ------- | ---- | ------ |
| Токио | Јапан   | 2020 | 1690   |
| Токио | Јапан   | 2019 | 1874   |
| Токио | Јапан   | 2018 | 1445   |

Шта примећујете у нашој табели? Можда примећујете да дуплирамо име и државу града изнова и изнова. То би могло заузети прилично простора за складиштење и углавном је непотребно имати више копија. На крају крајева, Токио има само једно име које нас занима.

У реду, хајде да пробамо нешто друго. Додаћемо нове колоне за сваку годину:

| Град     | Држава        | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| Токио    | Јапан         | 1445 | 1874 | 1690 |
| Атланта  | Сједињене Државе | 1779 | 1111 | 1683 |
| Окланд   | Нови Зеланд   | 1386 | 942  | 1176 |

Иако ово избегава дуплирање редова, додаје неке друге изазове. Морали бисмо да мењамо структуру наше табеле сваки пут када се дода нова година. Поред тога, како наши подаци расту, имање година као колона отежаваће преузимање и израчунавање вредности.

Зато нам требају више табела и релације. Раздвајањем наших података можемо избећи дуплирање и имати више флексибилности у начину рада са подацима.

## Концепти релација

Хајде да се вратимо на наше податке и одредимо како желимо да их поделимо. Знамо да желимо да чувамо име и државу за наше градове, па ће то вероватно најбоље функционисати у једној табели.

| Град     | Држава        |
| -------- | ------------- |
| Токио    | Јапан         |
| Атланта  | Сједињене Државе |
| Окланд   | Нови Зеланд   |

Али пре него што направимо следећу табелу, морамо да смислимо како да референцирамо сваки град. Потребан нам је неки облик идентификатора, ID или (у техничким терминима базе података) примарни кључ. Примарни кључ је вредност која се користи за идентификацију једног специфичног реда у табели. Иако би то могло бити засновано на самој вредности (на пример, могли бисмо користити име града), скоро увек би требало да буде број или други идентификатор. Не желимо да се ID икада промени јер би то прекинуло релацију. У већини случајева примарни кључ или ID ће бити аутоматски генерисан број.

> ✅ Примарни кључ се често скраћује као PK

### градови

| city_id | Град     | Држава        |
| ------- | -------- | ------------- |
| 1       | Токио    | Јапан         |
| 2       | Атланта  | Сједињене Државе |
| 3       | Окланд   | Нови Зеланд   |

> ✅ Приметићете да током овог предавања користимо термине "id" и "примарни кључ" наизменично. Концепти овде се примењују на DataFrames, које ћете касније истражити. DataFrames не користе терминологију "примарни кључ", али ћете приметити да се понашају на сличан начин.

Са креираном табелом градова, хајде да чувамо податке о падавинама. Уместо да дуплирамо пуне информације о граду, можемо користити ID. Такође треба да осигурамо да новокреирана табела има *id* колону, јер све табеле треба да имају ID или примарни кључ.

### падавине

| rainfall_id | city_id | Година | Количина |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

Приметите колону **city_id** унутар новокреиране табеле **падавине**. Ова колона садржи вредности које референцирају ID-ове у табели **градови**. У техничким терминима релационих података, ово се назива **страни кључ**; то је примарни кључ из друге табеле. Можете га једноставно замислити као референцу или показивач. **city_id** 1 референцира Токио.

> [!NOTE] 
> Страни кључ се често скраћује као FK

## Преузимање података

Са нашим подацима подељеним у две табеле, можда се питате како их можемо преузети. Ако користимо релациону базу података као што су MySQL, SQL Server или Oracle, можемо користити језик који се зове Структурирани језик упита или SQL. SQL (понекад изговарано као "сиквел") је стандардни језик који се користи за преузимање и модификовање података у релационој бази података.

Да бисте преузели податке, користите команду `SELECT`. У основи, **изаберете** колоне које желите да видите **из** табеле у којој се налазе. Ако желите да прикажете само имена градова, можете користити следеће:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` је место где наводите колоне, а `FROM` је место где наводите табеле.

> [!NOTE] 
> SQL синтакса није осетљива на велика и мала слова, што значи да `select` и `SELECT` значе исто. Међутим, у зависности од типа базе података коју користите, колоне и табеле могу бити осетљиве на велика и мала слова. Као резултат тога, најбоља пракса је да увек третирате све у програмирању као да је осетљиво на велика и мала слова. Када пишете SQL упите, уобичајена конвенција је да се кључне речи пишу великим словима.

Горњи упит ће приказати све градове. Замислимо да желимо да прикажемо само градове у Новом Зеланду. Потребан нам је неки облик филтера. SQL кључна реч за ово је `WHERE`, или "где је нешто тачно".

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## Спајање података

До сада смо преузимали податке из једне табеле. Сада желимо да спојимо податке из обе табеле **градови** и **падавине**. Ово се ради *спајањем* табела. Ефективно ћете направити везу између две табеле и ускладити вредности из колоне из сваке табеле.

У нашем примеру, ускладићемо колону **city_id** у табели **падавине** са колоном **city_id** у табели **градови**. Ово ће ускладити вредност падавина са њеним одговарајућим градом. Тип спајања који ћемо извршити је оно што се зове *унутрашње* спајање, што значи да ако неки редови не одговарају ничему из друге табеле, неће бити приказани. У нашем случају сваки град има податке о падавинама, па ће све бити приказано.

Хајде да преузмемо податке о падавинама за 2019. годину за све наше градове.

Урадићемо то у корацима. Први корак је да спојимо податке тако што ћемо назначити колоне за везу - **city_id** као што је раније истакнуто.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

Истакли смо две колоне које желимо, и чињеницу да желимо да спојимо табеле заједно преко **city_id**. Сада можемо додати `WHERE` изјаву да филтрирамо само годину 2019.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## Резиме

Релационе базе података су усредсређене на поделу информација између више табела које се затим враћају за приказ и анализу. Ово пружа висок степен флексибилности за извршавање прорачуна и манипулацију подацима. Видели сте основне концепте релационе базе података и како да извршите спајање између две табеле.

## 🚀 Изазов

На интернету постоји много релационих база података. Можете истражити податке користећи вештине које сте научили изнад.

## Квиз након предавања

## [Квиз након предавања](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## Преглед и самостално учење

Постоји неколико ресурса доступних на [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) за наставак вашег истраживања SQL-а и концепата релационих база података

- [Опис концепата релационих података](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Почните са упитима у Transact-SQL](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL је верзија SQL-а)
- [SQL садржај на Microsoft Learn](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## Задатак

[Наслов задатка](assignment.md)

---

**Одрицање од одговорности**:  
Овај документ је преведен помоћу услуге за превођење вештачке интелигенције [Co-op Translator](https://github.com/Azure/co-op-translator). Иако се трудимо да обезбедимо тачност, молимо вас да имате у виду да аутоматски преводи могу садржати грешке или нетачности. Оригинални документ на његовом изворном језику треба сматрати ауторитативним извором. За критичне информације препоручује се професионални превод од стране људи. Не преузимамо одговорност за било каква погрешна тумачења или неспоразуме који могу настати услед коришћења овог превода.