<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80d80300002ef4e77cc7631d5904bd6e",
  "translation_date": "2025-10-25T18:34:54+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "ru"
}
-->
# Работа с данными: реляционные базы данных

|![ Скетчноут от [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| Работа с данными: реляционные базы данных - _Скетчноут от [@nitya](https://twitter.com/nitya)_ |

Скорее всего, вы уже использовали электронные таблицы для хранения информации. У вас был набор строк и столбцов, где строки содержали информацию (или данные), а столбцы описывали эту информацию (иногда называемую метаданными). Реляционная база данных построена на этом базовом принципе столбцов и строк в таблицах, что позволяет хранить информацию в нескольких таблицах. Это дает возможность работать с более сложными данными, избегать дублирования и гибко исследовать данные. Давайте изучим основные концепции реляционной базы данных.

## [Тест перед лекцией](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## Все начинается с таблиц

В основе реляционной базы данных лежат таблицы. Как и в случае с электронной таблицей, таблица представляет собой набор столбцов и строк. Строка содержит данные или информацию, с которой мы хотим работать, например, название города или количество осадков. Столбцы описывают данные, которые они хранят.

Начнем наше исследование с создания таблицы для хранения информации о городах. Мы можем начать с их названия и страны. Это можно сохранить в таблице следующим образом:

| Город    | Страна        |
| -------- | ------------- |
| Токио    | Япония        |
| Атланта  | США           |
| Окленд   | Новая Зеландия|

Обратите внимание, что названия столбцов **город**, **страна** и **население** описывают хранимые данные, а каждая строка содержит информацию об одном городе.

## Недостатки подхода с одной таблицей

Скорее всего, приведенная выше таблица кажется вам довольно знакомой. Давайте добавим дополнительные данные в нашу растущую базу данных - годовое количество осадков (в миллиметрах). Мы сосредоточимся на годах 2018, 2019 и 2020. Если мы добавим данные для Токио, это может выглядеть примерно так:

| Город  | Страна | Год  | Количество |
| ------ | ------ | ---- | ---------- |
| Токио  | Япония | 2020 | 1690       |
| Токио  | Япония | 2019 | 1874       |
| Токио  | Япония | 2018 | 1445       |

Что вы замечаете в нашей таблице? Вы можете заметить, что мы многократно дублируем название и страну города. Это может занимать довольно много места и в основном является ненужным. В конце концов, у Токио есть только одно название, которое нас интересует.

Хорошо, давайте попробуем что-то другое. Добавим новые столбцы для каждого года:

| Город    | Страна        | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| Токио    | Япония        | 1445 | 1874 | 1690 |
| Атланта  | США           | 1779 | 1111 | 1683 |
| Окленд   | Новая Зеландия| 1386 | 942  | 1176 |

Хотя это позволяет избежать дублирования строк, возникают другие проблемы. Нам придется изменять структуру нашей таблицы каждый раз, когда появляется новый год. Кроме того, по мере роста данных использование годов в качестве столбцов усложнит их извлечение и вычисление значений.

Именно поэтому нам нужны несколько таблиц и связи между ними. Разделяя данные, мы можем избежать дублирования и получить больше гибкости в работе с ними.

## Концепция связей

Вернемся к нашим данным и определим, как мы хотим их разделить. Мы знаем, что хотим хранить название и страну для наших городов, поэтому это, вероятно, лучше всего подойдет для одной таблицы.

| Город    | Страна        |
| -------- | ------------- |
| Токио    | Япония        |
| Атланта  | США           |
| Окленд   | Новая Зеландия|

Но прежде чем создавать следующую таблицу, нам нужно понять, как ссылаться на каждый город. Нам нужна какая-то форма идентификатора, ID или (в технических терминах базы данных) первичный ключ. Первичный ключ - это значение, используемое для идентификации одной конкретной строки в таблице. Хотя это может быть основано на самом значении (например, мы могли бы использовать название города), оно почти всегда должно быть числом или другим идентификатором. Мы не хотим, чтобы ID когда-либо менялся, так как это нарушит связь. В большинстве случаев первичный ключ или ID будет автоматически генерируемым числом.

> ✅ Первичный ключ часто сокращается как PK

### города

| city_id | Город    | Страна        |
| ------- | -------- | ------------- |
| 1       | Токио    | Япония        |
| 2       | Атланта  | США           |
| 3       | Окленд   | Новая Зеландия|

> ✅ Вы заметите, что мы используем термины "id" и "первичный ключ" взаимозаменяемо в течение этого урока. Эти концепции применимы к DataFrames, которые вы изучите позже. DataFrames не используют терминологию "первичный ключ", однако вы заметите, что они ведут себя аналогично.

Создав таблицу городов, давайте сохраним данные о количестве осадков. Вместо того чтобы дублировать полную информацию о городе, мы можем использовать ID. Также следует убедиться, что вновь созданная таблица имеет столбец *id*, так как все таблицы должны иметь ID или первичный ключ.

### осадки

| rainfall_id | city_id | Год  | Количество |
| ----------- | ------- | ---- | ---------- |
| 1           | 1       | 2018 | 1445       |
| 2           | 1       | 2019 | 1874       |
| 3           | 1       | 2020 | 1690       |
| 4           | 2       | 2018 | 1779       |
| 5           | 2       | 2019 | 1111       |
| 6           | 2       | 2020 | 1683       |
| 7           | 3       | 2018 | 1386       |
| 8           | 3       | 2019 | 942        |
| 9           | 3       | 2020 | 1176       |

Обратите внимание на столбец **city_id** в недавно созданной таблице **осадки**. Этот столбец содержит значения, которые ссылаются на ID в таблице **города**. В технических терминах реляционных данных это называется **внешним ключом**; это первичный ключ из другой таблицы. Вы можете просто думать о нем как о ссылке или указателе. **city_id** 1 ссылается на Токио.

> [!NOTE] 
> Внешний ключ часто сокращается как FK

## Извлечение данных

С разделением данных на две таблицы вы можете задаться вопросом, как их извлечь. Если мы используем реляционную базу данных, такую как MySQL, SQL Server или Oracle, мы можем использовать язык, называемый язык структурированных запросов или SQL. SQL (иногда произносится как "сиквел") - это стандартный язык, используемый для извлечения и изменения данных в реляционной базе данных.

Для извлечения данных используется команда `SELECT`. В основе команды вы **выбираете** столбцы, которые хотите увидеть, **из** таблицы, в которой они содержатся. Если вы хотите отобразить только названия городов, вы можете использовать следующий запрос:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` - это место, где вы перечисляете столбцы, а `FROM` - место, где вы перечисляете таблицы.

> [!NOTE] 
> Синтаксис SQL нечувствителен к регистру, то есть `select` и `SELECT` означают одно и то же. Однако, в зависимости от типа базы данных, которую вы используете, столбцы и таблицы могут быть чувствительны к регистру. Поэтому рекомендуется всегда относиться ко всему в программировании как к чувствительному к регистру. При написании SQL-запросов общепринято писать ключевые слова заглавными буквами.

Запрос выше отобразит все города. Представьте, что мы хотим отобразить только города в Новой Зеландии. Нам нужен какой-то фильтр. Ключевое слово SQL для этого - `WHERE`, или "где что-то истинно".

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## Объединение данных

До сих пор мы извлекали данные из одной таблицы. Теперь мы хотим объединить данные из таблиц **города** и **осадки**. Это делается путем *объединения* их вместе. Вы фактически создаете связь между двумя таблицами, сопоставляя значения из столбцов каждой таблицы.

В нашем примере мы сопоставим столбец **city_id** в таблице **осадки** со столбцом **city_id** в таблице **города**. Это позволит сопоставить количество осадков с соответствующим городом. Тип объединения, который мы будем использовать, называется *внутренним* объединением, что означает, что если строки не совпадают с чем-либо из другой таблицы, они не будут отображаться. В нашем случае у каждого города есть данные об осадках, поэтому все будет отображено.

Давайте извлечем данные об осадках за 2019 год для всех наших городов.

Мы сделаем это поэтапно. Первый шаг - объединить данные, указав столбцы для связи - **city_id**, как было отмечено ранее.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

Мы указали два столбца, которые нам нужны, и то, что мы хотим объединить таблицы по столбцу **city_id**. Теперь мы можем добавить оператор `WHERE`, чтобы отфильтровать только данные за 2019 год.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## Итоги

Реляционные базы данных сосредоточены на разделении информации между несколькими таблицами, которые затем объединяются для отображения и анализа. Это обеспечивает высокий уровень гибкости для выполнения вычислений и других манипуляций с данными. Вы познакомились с основными концепциями реляционной базы данных и узнали, как выполнять объединение между двумя таблицами.

## 🚀 Задание

Существует множество реляционных баз данных, доступных в интернете. Вы можете исследовать данные, используя навыки, которые вы изучили выше.

## Тест после лекции

## [Тест после лекции](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## Обзор и самостоятельное изучение

На [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) доступно множество ресурсов для продолжения изучения SQL и концепций реляционных баз данных.

- [Описание концепций реляционных данных](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Начало работы с запросами на Transact-SQL](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL - это версия SQL)
- [Контент по SQL на Microsoft Learn](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## Задание

[Название задания](assignment.md)

---

**Отказ от ответственности**:  
Этот документ был переведен с использованием сервиса автоматического перевода [Co-op Translator](https://github.com/Azure/co-op-translator). Несмотря на наши усилия обеспечить точность, автоматические переводы могут содержать ошибки или неточности. Оригинальный документ на его родном языке следует считать авторитетным источником. Для получения критически важной информации рекомендуется профессиональный перевод человеком. Мы не несем ответственности за любые недоразумения или неправильные интерпретации, возникающие в результате использования данного перевода.