<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "9399d7b4767e75068f95ce5c660b285c",
  "translation_date": "2025-09-06T06:54:51+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "mo"
}
-->
# 使用資料：關聯式資料庫

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| 使用資料：關聯式資料庫 - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

你可能曾經使用過試算表來儲存資訊。試算表由一組列和欄組成，其中列包含資訊（或資料），欄描述資訊（有時稱為元資料）。關聯式資料庫基於這種表格的核心原則，允許你將資訊分散到多個表格中。這使得你可以處理更複雜的資料，避免重複，並且在探索資料時擁有更大的靈活性。讓我們來探討關聯式資料庫的概念。

## [課前測驗](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## 一切從表格開始

關聯式資料庫的核心是表格。就像試算表一樣，表格是由欄和列組成的集合。列包含我們希望處理的資料或資訊，例如城市名稱或降雨量。欄則描述它們所儲存的資料。

讓我們從建立一個儲存城市資訊的表格開始探索。我們可能會從城市名稱和國家開始。你可以將它儲存在如下的表格中：

| 城市     | 國家         |
| -------- | ------------ |
| 東京     | 日本         |
| 亞特蘭大 | 美國         |
| 奧克蘭   | 紐西蘭       |

注意，**城市**、**國家**和**人口**這些欄位名稱描述了所儲存的資料，而每一列都包含一個城市的資訊。

## 單一表格方法的缺點

上述的表格可能看起來相當熟悉。現在讓我們開始向這個新興的資料庫添加一些額外的資料——年度降雨量（以毫米為單位）。我們將專注於2018年、2019年和2020年。如果我們要為東京添加這些資料，可能會像這樣：

| 城市  | 國家   | 年份 | 降雨量 |
| ----- | ------ | ---- | ------ |
| 東京  | 日本   | 2020 | 1690   |
| 東京  | 日本   | 2019 | 1874   |
| 東京  | 日本   | 2018 | 1445   |

你注意到我們的表格有什麼問題嗎？你可能會注意到我們重複了城市名稱和國家多次。這可能會佔用相當多的儲存空間，而且大部分情況下是不必要的。畢竟，東京的名稱只有一個。

好吧，讓我們嘗試另一種方法。讓我們為每一年添加新的欄位：

| 城市     | 國家         | 2018 | 2019 | 2020 |
| -------- | ------------ | ---- | ---- | ---- |
| 東京     | 日本         | 1445 | 1874 | 1690 |
| 亞特蘭大 | 美國         | 1779 | 1111 | 1683 |
| 奧克蘭   | 紐西蘭       | 1386 | 942  | 1176 |

雖然這避免了列的重複，但也帶來了其他挑戰。我們每次新增一年都需要修改表格的結構。此外，隨著資料的增長，將年份作為欄位會使得檢索和計算值變得更加困難。

這就是為什麼我們需要多個表格和關係。通過拆分資料，我們可以避免重複，並在處理資料時擁有更大的靈活性。

## 關係的概念

讓我們回到資料，並決定如何拆分它們。我們知道我們希望儲存城市的名稱和國家，因此這可能最適合放在一個表格中。

| 城市     | 國家         |
| -------- | ------------ |
| 東京     | 日本         |
| 亞特蘭大 | 美國         |
| 奧克蘭   | 紐西蘭       |

但在建立下一個表格之前，我們需要弄清楚如何引用每個城市。我們需要某種形式的識別碼、ID或（在技術資料庫術語中）主鍵。主鍵是一個用於識別表格中特定列的值。雖然這可以基於某個值本身（例如，我們可以使用城市名稱），但它幾乎應該是一個數字或其他識別碼。我們不希望ID發生變化，因為這會破壞關係。你會發現，在大多數情況下，主鍵或ID通常是自動生成的數字。

> ✅ 主鍵通常縮寫為PK

### 城市表格

| 城市ID | 城市     | 國家         |
| ------ | -------- | ------------ |
| 1      | 東京     | 日本         |
| 2      | 亞特蘭大 | 美國         |
| 3      | 奧克蘭   | 紐西蘭       |

> ✅ 在本課程中，你會注意到我們交替使用“ID”和“主鍵”這些術語。這些概念也適用於DataFrame，你稍後會探索。DataFrame不使用“主鍵”這一術語，但你會注意到它們的行為非常相似。

建立城市表格後，讓我們儲存降雨量。與其重複城市的完整資訊，我們可以使用ID。我們還應確保新建立的表格有一個*ID*欄位，因為所有表格都應該有一個ID或主鍵。

### 降雨量表格

| 降雨量ID | 城市ID | 年份 | 降雨量 |
| -------- | ------ | ---- | ------ |
| 1        | 1      | 2018 | 1445   |
| 2        | 1      | 2019 | 1874   |
| 3        | 1      | 2020 | 1690   |
| 4        | 2      | 2018 | 1779   |
| 5        | 2      | 2019 | 1111   |
| 6        | 2      | 2020 | 1683   |
| 7        | 3      | 2018 | 1386   |
| 8        | 3      | 2019 | 942    |
| 9        | 3      | 2020 | 1176   |

注意新建立的**降雨量**表格中的**城市ID**欄位。這個欄位包含引用**城市**表格中ID的值。在技術關聯資料術語中，這被稱為**外鍵**；它是另一個表格的主鍵。你可以簡單地將其視為一個引用或指標。**城市ID** 1指向東京。

> [!NOTE] 外鍵通常縮寫為FK

## 資料的檢索

將資料分成兩個表格後，你可能會想知道如何檢索它。如果我們使用像MySQL、SQL Server或Oracle這樣的關聯式資料庫，我們可以使用一種叫做結構化查詢語言（SQL）的語言。SQL（有時讀作sequel）是一種標準語言，用於在關聯式資料庫中檢索和修改資料。

要檢索資料，你可以使用指令`SELECT`。其核心是，你**選擇**想要查看的欄位，**從**它們所在的表格中。如果你只想顯示城市的名稱，可以使用以下指令：

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT`是列出欄位的地方，`FROM`是列出表格的地方。

> [NOTE] SQL語法不區分大小寫，這意味著`select`和`SELECT`是相同的。然而，根據你使用的資料庫類型，欄位和表格可能區分大小寫。因此，最佳做法是始終將程式中的所有內容視為區分大小寫。在撰寫SQL查詢時，常見的慣例是將關鍵字全部用大寫字母表示。

上述查詢將顯示所有城市。假設我們只想顯示紐西蘭的城市。我們需要某種形式的篩選器。SQL的關鍵字是`WHERE`，即“某些條件為真”。

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## 資料的連結

到目前為止，我們已經從單一表格中檢索資料。現在我們希望將**城市**和**降雨量**的資料結合在一起。這可以通過*連結*它們來完成。你將有效地在兩個表格之間建立一個接合點，並匹配每個表格中的欄位值。

在我們的例子中，我們將匹配**降雨量**表格中的**城市ID**欄位與**城市**表格中的**城市ID**欄位。這將把降雨量值與其相應的城市匹配起來。我們將執行一種稱為*內部連結*的操作，這意味著如果某些列未與另一個表格中的任何內容匹配，它們將不會顯示。在我們的例子中，每個城市都有降雨量，因此所有內容都會顯示。

讓我們檢索2019年所有城市的降雨量。

我們將分步進行。第一步是通過指明接合點的欄位來連結資料——如前所述的**城市ID**。

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

我們已經突出了我們想要的兩個欄位，以及我們希望通過**城市ID**連結表格的事實。現在我們可以添加`WHERE`語句來篩選出僅2019年的資料。

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## 總結

關聯式資料庫的核心是將資訊分割到多個表格中，然後將其重新組合以進行顯示和分析。這提供了高度的靈活性來執行計算或以其他方式操作資料。你已經了解了關聯式資料庫的核心概念，以及如何在兩個表格之間進行連結。

## 🚀 挑戰

網路上有許多關聯式資料庫可供使用。你可以使用上述學到的技能來探索這些資料。

## 課後測驗

## [課後測驗](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## 回顧與自學

[Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum)上有許多資源可供你繼續探索SQL和關聯式資料庫的概念

- [描述關聯資料的概念](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [開始使用Transact-SQL進行查詢](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum)（Transact-SQL是SQL的一個版本）
- [Microsoft Learn上的SQL內容](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## 作業

[作業標題](assignment.md)

---

**免責聲明**：  
本文件已使用 AI 翻譯服務 [Co-op Translator](https://github.com/Azure/co-op-translator) 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。