<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80d80300002ef4e77cc7631d5904bd6e",
  "translation_date": "2025-10-25T19:10:54+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "my"
}
-->
# ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်များ

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်များ - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

သင်ဟာ အတိတ်ကာလမှာ အချက်အလက်တွေကို သိမ်းဆည်းဖို့ spreadsheet ကို အသုံးပြုဖူးတယ်ဆိုတာ အလားအလာရှိပါတယ်။ သင်မှာ အတန်းတွေ၊ ကော်လံတွေရှိပြီး အတန်းတွေမှာ အချက်အလက် (သို့မဟုတ် ဒေတာ) တွေပါဝင်ပြီး ကော်လံတွေက အချက်အလက်တွေကို ဖော်ပြပေးပါတယ် (တခါတရံ metadata လို့ခေါ်ပါတယ်)။ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ဟာ ကော်လံနဲ့ အတန်းတွေကို အခြေခံပြီး တစ်ခုပေါင်းစည်းထားတဲ့ စနစ်ဖြစ်ပြီး အချက်အလက်တွေကို အတန်းပေါင်းများစွာမှာ ဖြန့်ဝေထားနိုင်ပါတယ်။ ဒါဟာ ပိုမိုရှုပ်ထွေးတဲ့ ဒေတာတွေနဲ့ အလုပ်လုပ်နိုင်စေပြီး အချက်အလက်တွေကို ထပ်တူထပ်မျှဖြစ်ခြင်းကို ရှောင်ရှားနိုင်စေပြီး ဒေတာကို စုံစမ်းဖို့ ပိုမိုလွယ်ကူစေပါတယ်။ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ရဲ့ အယူအဆတွေကို လေ့လာကြည့်ရအောင်။

## [Pre-lecture quiz](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## အားလုံးဟာ အတန်းတွေကနေ စတင်ပါတယ်

ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ရဲ့ အခြေခံမှာ အတန်းတွေရှိပါတယ်။ spreadsheet နဲ့တူတူပဲ အတန်းဟာ ကော်လံနဲ့ အတန်းတွေကို စုပေါင်းထားတဲ့ collection တစ်ခုဖြစ်ပါတယ်။ အတန်းတွေမှာ ကျွန်တော်တို့ အလုပ်လုပ်ချင်တဲ့ ဒေတာ သို့မဟုတ် အချက်အလက်တွေ ပါဝင်ပြီး၊ ကော်လံတွေက သူတို့ သိမ်းဆည်းထားတဲ့ ဒေတာကို ဖော်ပြပေးပါတယ်။

ကျွန်တော်တို့ မြို့တွေအကြောင်း အချက်အလက်တွေကို သိမ်းဆည်းဖို့ အတန်းတစ်ခုကို စတင်ဖန်တီးပြီး လေ့လာကြည့်ရအောင်။ သူတို့ရဲ့ နာမည်နဲ့ နိုင်ငံကို စတင်ထားနိုင်ပါတယ်။ ဒါကို အောက်ပါအတိုင်း အတန်းတစ်ခုမှာ သိမ်းဆည်းထားနိုင်ပါတယ် -

| City     | Country       |
| -------- | ------------- |
| Tokyo    | Japan         |
| Atlanta  | United States |
| Auckland | New Zealand   |

**city**, **country** နဲ့ **population** ကော်လံနာမည်တွေဟာ သိမ်းဆည်းထားတဲ့ ဒေတာကို ဖော်ပြပေးပြီး၊ အတန်းတစ်ခုစီမှာ မြို့တစ်မြို့အကြောင်း အချက်အလက်တွေ ပါဝင်ပါတယ်။

## တစ်ခုတည်းသော အတန်းနည်းလမ်းရဲ့ အားနည်းချက်များ

အထက်ပါ အတန်းဟာ သင့်အတွက် အလွန်ရိုးရှင်းပြီး ရင်းနှီးနေမယ်လို့ ထင်ပါတယ်။ အခု ကျွန်တော်တို့ database ကို တိုးချဲ့ဖို့ အပိုဒေတာတွေ ထည့်သွင်းကြည့်ရအောင် - နှစ်စဉ် ရေရွှံ့ပမာဏ (မီလီမီတာဖြင့်)။ ၂၀၁၈၊ ၂၀၁၉ နဲ့ ၂၀၂၀ နှစ်တွေကို အာရုံစိုက်မယ်။ Tokyo အတွက် ဒေတာတွေကို ထည့်သွင်းမယ်ဆိုရင် အောက်ပါအတိုင်း ဖြစ်နိုင်ပါတယ် -

| City  | Country | Year | Amount |
| ----- | ------- | ---- | ------ |
| Tokyo | Japan   | 2020 | 1690   |
| Tokyo | Japan   | 2019 | 1874   |
| Tokyo | Japan   | 2018 | 1445   |

ကျွန်တော်တို့ရဲ့ အတန်းကို သတိထားမိတာရှိလား? ကျွန်တော်တို့ဟာ မြို့နာမည်နဲ့ နိုင်ငံအချက်အလက်တွေကို ထပ်တူထပ်မျှ သိမ်းဆည်းထားတာကို သတိထားမိနိုင်ပါတယ်။ ဒါဟာ သိမ်းဆည်းမှုအများကြီးကို လိုအပ်စေပြီး၊ Tokyo ဟာ ကျွန်တော်တို့စိတ်ဝင်စားတဲ့ နာမည်တစ်ခုတည်းရှိတာကြောင့် အဓိကအားဖြင့် မလိုအပ်ပါဘူး။

အိုကေ၊ တခြားနည်းလမ်းတစ်ခုကို ကြိုးစားကြည့်ရအောင်။ နှစ်စဉ်အတွက် ကော်လံအသစ်တွေ ထည့်သွင်းကြည့်ရအောင် -

| City     | Country       | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| Tokyo    | Japan         | 1445 | 1874 | 1690 |
| Atlanta  | United States | 1779 | 1111 | 1683 |
| Auckland | New Zealand   | 1386 | 942  | 1176 |

ဒါဟာ အတန်းတွေကို ထပ်တူထပ်မျှဖြစ်ခြင်းကို ရှောင်ရှားနိုင်ပေမယ့် အခြားအခက်အခဲတွေကို ဖြစ်စေပါတယ်။ နှစ်အသစ်တစ်ခုရှိတိုင်း ကျွန်တော်တို့ရဲ့ အတန်းဖွဲ့စည်းမှုကို ပြောင်းလဲဖို့ လိုအပ်လာနိုင်ပါတယ်။ ထို့အပြင်၊ ဒေတာတွေ တိုးလာတာနဲ့အမျှ နှစ်တွေကို ကော်လံအဖြစ်ထားရင် တန်ဖိုးတွေကို ရှာဖွေခြင်းနဲ့ တွက်ချက်ခြင်းတွေ ပိုမိုခက်ခဲလာနိုင်ပါတယ်။

ဒါကြောင့် အတန်းများစွာနဲ့ ဆက်နွယ်မှုတွေ လိုအပ်ပါတယ်။ ဒေတာတွေကို ခွဲခြားထားခြင်းအားဖြင့် ထပ်တူထပ်မျှဖြစ်ခြင်းကို ရှောင်ရှားနိုင်ပြီး ဒေတာနဲ့ အလုပ်လုပ်တဲ့ နည်းလမ်းမှာ ပိုမိုလွယ်ကူမှုရှိစေပါတယ်။

## ဆက်နွယ်မှုရဲ့ အယူအဆများ

ကျွန်တော်တို့ရဲ့ ဒေတာကို ပြန်လည်သုံးသပ်ပြီး ဘယ်လို ခွဲခြားထားမလဲ ဆုံးဖြတ်ရအောင်။ ကျွန်တော်တို့ဟာ မြို့နာမည်နဲ့ နိုင်ငံကို သိမ်းဆည်းချင်တယ်ဆိုတော့ ဒါဟာ အတန်းတစ်ခုမှာ သိမ်းဆည်းဖို့ အကောင်းဆုံးဖြစ်နိုင်ပါတယ်။

| City     | Country       |
| -------- | ------------- |
| Tokyo    | Japan         |
| Atlanta  | United States |
| Auckland | New Zealand   |

ဒါပေမယ့် အတန်းအသစ်ကို ဖန်တီးမယ့်အခါမှာ ကျွန်တော်တို့ဟာ မြို့တစ်ခုစီကို ရည်ညွှန်းဖို့ နည်းလမ်းတစ်ခုကို ရှာဖွေရမယ်။ ID သို့မဟုတ် (နည်းပညာဆိုင်ရာ ဒေတာဘေ့စ်စကားလုံးတွေအရ) primary key တစ်ခုလိုအပ်ပါတယ်။ Primary key ဟာ အတန်းတစ်ခုထဲမှာ အတန်းတစ်ခုကို သတ်မှတ်ဖို့ အသုံးပြုတဲ့ တန်ဖိုးတစ်ခုဖြစ်ပါတယ်။ ဒါဟာ တန်ဖိုးကို အခြေခံပြီး (ဥပမာ မြို့နာမည်ကို အသုံးပြုနိုင်ပါတယ်) ဖြစ်နိုင်ပေမယ့် အမြဲတမ်းနံပါတ် သို့မဟုတ် အခြား ID တစ်ခုဖြစ်သင့်ပါတယ်။ ID ဟာ ဘယ်တော့မှ မပြောင်းလဲသင့်ပါဘူး၊ ပြောင်းလဲမယ်ဆိုရင် ဆက်နွယ်မှုကို ပျက်စီးစေမှာဖြစ်ပါတယ်။ အများအားဖြင့် primary key သို့မဟုတ် ID ဟာ auto-generated နံပါတ်ဖြစ်လေ့ရှိပါတယ်။

> ✅ Primary key ကို အတိုကောက် PK လို့ ခေါ်လေ့ရှိပါတယ်

### cities

| city_id | City     | Country       |
| ------- | -------- | ------------- |
| 1       | Tokyo    | Japan         |
| 2       | Atlanta  | United States |
| 3       | Auckland | New Zealand   |

> ✅ ဒီသင်ခန်းစာအတွင်းမှာ "id" နဲ့ "primary key" ဆိုတဲ့ စကားလုံးတွေကို အလွယ်တကူ အသုံးပြုထားတာကို သတိထားမိပါလိမ့်မယ်။ ဒီအယူအဆတွေဟာ DataFrames တွေမှာလည်း သက်ဆိုင်ပါတယ်၊ သင်ဟာ နောက်ပိုင်းမှာ DataFrames တွေကို လေ့လာမယ်။ DataFrames တွေမှာ "primary key" ဆိုတဲ့ စကားလုံးကို မသုံးပေမယ့်၊ သူတို့ဟာ အတူတူပဲ လုပ်ဆောင်လေ့ရှိပါတယ်။

ကျွန်တော်တို့ရဲ့ cities အတန်းကို ဖန်တီးပြီးရင်၊ ရေရွှံ့ပမာဏကို သိမ်းဆည်းရမယ်။ မြို့အချက်အလက်အပြည့်အစုံကို ထပ်တူထပ်မျှ သိမ်းဆည်းမယ့်အစား ID ကို အသုံးပြုနိုင်ပါတယ်။ အသစ်ဖန်တီးထားတဲ့ အတန်းမှာလည်း *id* ကော်လံတစ်ခုရှိအောင် သေချာရမယ်၊ အတန်းအားလုံးမှာ id သို့မဟုတ် primary key တစ်ခုရှိသင့်ပါတယ်။

### rainfall

| rainfall_id | city_id | Year | Amount |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

အသစ်ဖန်တီးထားတဲ့ **rainfall** အတန်းထဲမှာ **city_id** ကော်လံကို သတိထားမိပါလိမ့်မယ်။ ဒီကော်လံဟာ **cities** အတန်းထဲမှာရှိတဲ့ ID တွေကို ရည်ညွှန်းတဲ့ တန်ဖိုးတွေကို ပါဝင်ပါတယ်။ နည်းပညာဆိုင်ရာ ဆက်နွယ်မှုရှိတဲ့ ဒေတာစကားလုံးတွေအရ၊ ဒါကို **foreign key** လို့ ခေါ်ပါတယ်။ ဒါဟာ တခြားအတန်းက primary key တစ်ခုဖြစ်ပါတယ်။ **city_id** 1 ဟာ Tokyo ကို ရည်ညွှန်းပါတယ်။

> [!NOTE] 
> Foreign key ကို အတိုကောက် FK လို့ ခေါ်လေ့ရှိပါတယ်

## ဒေတာကို ရှာဖွေခြင်း

ကျွန်တော်တို့ရဲ့ ဒေတာကို အတန်းနှစ်ခုထဲမှာ ခွဲထားပြီးနောက်၊ ဒေတာကို ဘယ်လို ရှာဖွေမလဲဆိုတာ သင် စဉ်းစားနေလိမ့်မယ်။ MySQL, SQL Server သို့မဟုတ် Oracle ကဲ့သို့သော ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ကို အသုံးပြုမယ်ဆိုရင် Structured Query Language (SQL) လို့ခေါ်တဲ့ ဘာသာစကားတစ်ခုကို အသုံးပြုနိုင်ပါတယ်။ SQL (တခါတရံ sequel လို့လည်း အသံထွက်) ဟာ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ထဲမှာ ဒေတာကို ရှာဖွေခြင်းနဲ့ ပြင်ဆင်ခြင်းအတွက် အသုံးပြုတဲ့ စံဘာသာစကားတစ်ခုဖြစ်ပါတယ်။

ဒေတာကို ရှာဖွေဖို့ `SELECT` ဆိုတဲ့ command ကို အသုံးပြုပါတယ်။ အခြေခံအားဖြင့် သင် **ကြည့်ချင်တဲ့** ကော်လံတွေကို **ရှိတဲ့** အတန်းထဲကနေ **ရွေးချယ်** ပါတယ်။ သင်မြို့နာမည်တွေကိုသာ ပြသချင်တယ်ဆိုရင် အောက်ပါအတိုင်း အသုံးပြုနိုင်ပါတယ် -

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` ဟာ သင်ကြည့်ချင်တဲ့ ကော်လံတွေကို ရေးတဲ့နေရာဖြစ်ပြီး၊ `FROM` ဟာ သူတို့ရှိတဲ့ အတန်းတွေကို ရေးတဲ့နေရာဖြစ်ပါတယ်။

> [!NOTE] 
> SQL syntax ဟာ case-insensitive ဖြစ်ပါတယ်၊ `select` နဲ့ `SELECT` ဟာ တူညီတဲ့ အဓိပ္ပာယ်ရှိပါတယ်။ သို့သော်၊ သင်အသုံးပြုနေတဲ့ ဒေတာဘေ့စ်အမျိုးအစားပေါ်မူတည်ပြီး ကော်လံနဲ့ အတန်းတွေဟာ case-sensitive ဖြစ်နိုင်ပါတယ်။ ဒါကြောင့်၊ programming မှာ အရာအားလုံးကို case-sensitive ဖြစ်တယ်လို့ အမြဲတမ်း သတ်မှတ်ထားသင့်ပါတယ်။ SQL queries တွေကို ရေးတဲ့အခါမှာ keyword တွေကို အမြဲတမ်း အကြီးစာလုံးနဲ့ ရေးဖို့ သင့်တော်ပါတယ်။

အထက်ပါ query ဟာ မြို့အားလုံးကို ပြသပေးပါမယ်။ New Zealand မှာရှိတဲ့ မြို့တွေကိုသာ ပြသချင်တယ်ဆိုရင် ကျွန်တော်တို့မှာ filter တစ်ခုလိုအပ်ပါတယ်။ SQL keyword ဟာ `WHERE` ဖြစ်ပြီး၊ "တစ်ခုခုမှန်တဲ့နေရာမှာ" ဆိုတဲ့ အဓိပ္ပာယ်ရှိပါတယ်။

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## ဒေတာကို ပေါင်းစည်းခြင်း

အခုထိ ကျွန်တော်တို့ဟာ တစ်ခုတည်းသော အတန်းကနေ ဒေတာကို ရှာဖွေခဲ့ပါတယ်။ အခုတော့ **cities** နဲ့ **rainfall** အတန်းနှစ်ခုက ဒေတာတွေကို အတူတကွ ပေါင်းစည်းချင်ပါတယ်။ ဒါကို *joining* လို့ ခေါ်ပါတယ်။ သင်ဟာ အတန်းနှစ်ခုကြားမှာ seam တစ်ခုကို ဖန်တီးပြီး၊ အတန်းတစ်ခုစီက ကော်လံတစ်ခုစီရဲ့ တန်ဖိုးတွေကို တိုက်ဆိုင်စေမှာ ဖြစ်ပါတယ်။

ကျွန်တော်တို့ရဲ့ ဥပမာမှာ **rainfall** ထဲက **city_id** ကော်လံကို **cities** ထဲက **city_id** ကော်လံနဲ့ တိုက်ဆိုင်စေမှာ ဖြစ်ပါတယ်။ ဒါဟာ ရေရွှံ့ပမာဏကို သူ့ရဲ့ မြို့နဲ့ တိုက်ဆိုင်စေမှာ ဖြစ်ပါတယ်။ ကျွန်တော်တို့လုပ်ဆောင်မယ့် join အမျိုးအစားက *inner* join လို့ ခေါ်ပြီး၊ အတန်းတွေဟာ တစ်ခုနဲ့ တစ်ခု မတိုက်ဆိုင်ရင် အတန်းတွေကို မပြသပါဘူး။ ကျွန်တော်တို့ရဲ့ ဥပမာမှာ မြို့တိုင်းမှာ ရေရွှံ့ရှိတဲ့အတွက် အားလုံးကို ပြသပါမယ်။

အခု ကျွန်တော်တို့ရဲ့ မြို့အားလုံးအတွက် ၂၀၁၉ ခုနှစ်ရဲ့ ရေရွှံ့ပမာဏကို ရှာဖွေကြည့်ရအောင်။

ကျွန်တော်တို့ ဒီကို အဆင့်ဆင့်လုပ်ဆောင်ပါမယ်။ ပထမအဆင့်က **city_id** ကော်လံကို seam အဖြစ် သတ်မှတ်ပြီး ဒေတာတွေကို ပေါင်းစည်းဖို့ ဖြစ်ပါတယ်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

ကျွန်တော်တို့ဟာ ရွေးချယ်ထားတဲ့ ကော်လံနှစ်ခုနဲ့ **city_id** ကော်လံကို seam အဖြစ် သတ်မှတ်ထားပါတယ်။ အခုတော့ `WHERE` statement ကို ထည့်သွင်းပြီး ၂၀၁၉ ခုနှစ်ကိုသာ filter လုပ်ပါမယ်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## အကျဉ်းချုပ်

ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်တွေဟာ အချက်အလက်တွေကို အတန်းများစွာကြားမှာ ခွဲထားပြီး ပြန်လည်ပြသခြင်းနဲ့ ချိန်ညှိခြင်းအတွက် အတူတကွ ပေါင်းစည်းထားပါတယ်။ ဒါဟာ ဒေတာတွေကို တွက်ချက်ခြင်းနဲ့ အခြားသော အလုပ်လုပ်ခြင်းတွေကို လွယ်ကူစေတဲ့ အလွန်မြင့်မားတဲ့ အလွယ်ကူမှုကို ပေးစွမ်းပါတယ်။ သင်ဟာ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ရဲ့ အခြေခံအယူအဆတွေကို မြင်တွေ့ခဲ့ပြီး၊ အတန်းနှစ်ခုကြားမှာ join လုပ်ခြင်းကို ဘယ်လိုလုပ်ရမယ်ဆိုတာကိုလည်း လေ့လာခဲ့ပါတယ်။

## 🚀 စိန်ခေါ်မှု

အင်တာနက်မှာ ဆက်န

---

**အကြောင်းကြားချက်**:  
ဤစာရွက်စာတမ်းကို AI ဘာသာပြန်ဝန်ဆောင်မှု [Co-op Translator](https://github.com/Azure/co-op-translator) ကို အသုံးပြု၍ ဘာသာပြန်ထားပါသည်။ ကျွန်ုပ်တို့သည် တိကျမှုအတွက် ကြိုးစားနေသော်လည်း အလိုအလျောက် ဘာသာပြန်မှုများတွင် အမှားများ သို့မဟုတ် မမှန်ကန်မှုများ ပါဝင်နိုင်သည်ကို သတိပြုပါ။ မူရင်းဘာသာစကားဖြင့် ရေးသားထားသော စာရွက်စာတမ်းကို အာဏာတရားရှိသော အရင်းအမြစ်အဖြစ် သတ်မှတ်သင့်ပါသည်။ အရေးကြီးသော အချက်အလက်များအတွက် လူက ဘာသာပြန်မှုကို အကြံပြုပါသည်။ ဤဘာသာပြန်မှုကို အသုံးပြုခြင်းမှ ဖြစ်ပေါ်လာသော အလွဲအမှားများ သို့မဟုတ် အနားလွဲမှုများအတွက် ကျွန်ုပ်တို့သည် တာဝန်မယူပါ။