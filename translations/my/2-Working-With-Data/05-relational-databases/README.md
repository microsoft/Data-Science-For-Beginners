<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "9399d7b4767e75068f95ce5c660b285c",
  "translation_date": "2025-09-05T20:12:11+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "my"
}
-->
# ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်များ

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| ဒေတာနှင့်အလုပ်လုပ်ခြင်း: ဆက်နွယ်မှုရှိသော ဒေတာဘေ့စ်များ - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

သင်ဟာ အတိတ်ကာလမှာ အချက်အလက်တွေကို သိမ်းဆည်းဖို့ spreadsheet တစ်ခုကို အသုံးပြုဖူးနိုင်ပါတယ်။ သင်မှာ အတန်းနဲ့ ကော်လံတွေရှိပြီး အတန်းတွေမှာ အချက်အလက် (သို့မဟုတ် ဒေတာ) တွေပါဝင်ပြီး ကော်လံတွေက အချက်အလက်ကို ဖော်ပြပေးပါတယ် (တစ်ခါတစ်ရံ metadata လို့ခေါ်ပါတယ်)။ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ဟာ အတန်းနဲ့ ကော်လံတွေကို အခြေခံပြီး တစ်ခုပေါ်တစ်ခု ဆက်နွယ်ထားတဲ့ အချက်အလက်တွေကို အတန်းများစွာမှာ ဖြန့်ဝေထားနိုင်ပါတယ်။ ဒါက သင့်ကို ပိုမိုရှုပ်ထွေးတဲ့ ဒေတာတွေနဲ့ အလုပ်လုပ်နိုင်စေပြီး အချက်အလက်ထပ်နေမှုကို ရှောင်ရှားနိုင်စေပြီး ဒေတာကို ရှာဖွေတဲ့နည်းလမ်းမှာ လွယ်ကူမှုရှိစေပါတယ်။ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ရဲ့ အယူအဆတွေကို လေ့လာကြမယ်။

## [Pre-lecture quiz](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## အားလုံးဟာ အတန်းတွေကနေ စတင်ပါတယ်

ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ရဲ့ အခြေခံမှာ အတန်းတွေရှိပါတယ်။ spreadsheet နဲ့တူတူပဲ အတန်းဟာ ကော်လံနဲ့ အတန်းတွေကို စုပေါင်းထားတဲ့ collection တစ်ခုဖြစ်ပါတယ်။ အတန်းတွေမှာ သင်လုပ်ဆောင်ချင်တဲ့ ဒေတာ (ဥပမာ မြို့နာမည် သို့မဟုတ် မိုးရွာသွန်းမှု) ပါဝင်ပြီး ကော်လံတွေက ဒေတာကို ဖော်ပြပေးပါတယ်။

မြို့နာမည်နဲ့ နိုင်ငံအချက်အလက်တွေကို သိမ်းဆည်းဖို့ အတန်းတစ်ခုကို စတင်ကြည့်ရအောင်။ ဒါကို အောက်ပါအတိုင်း သိမ်းဆည်းနိုင်ပါတယ်။

| မြို့      | နိုင်ငံ          |
| -------- | ------------- |
| တိုကျို   | ဂျပန်           |
| အတ္လန်တာ | အမေရိကန်        |
| အော့ကလန် | နယူးဇီလန်       |

**မြို့**, **နိုင်ငံ** နဲ့ **လူဦးရေ** ကော်လံနာမည်တွေက သိမ်းဆည်းထားတဲ့ ဒေတာကို ဖော်ပြပေးပြီး အတန်းတစ်ခုစီမှာ မြို့တစ်မြို့အကြောင်းအချက်အလက်တွေ ပါဝင်ပါတယ်။

## တစ်ခုတည်းသော အတန်းနည်းလမ်းရဲ့ အားနည်းချက်များ

အထက်ပါအတန်းဟာ သင့်အတွက် ရိုးရှင်းပြီး မျက်နှာကျက်ဖြစ်နိုင်ပါတယ်။ ဒေတာဘေ့စ်ကို တိုးချဲ့ဖို့ နှစ်စဉ် မိုးရွာသွန်းမှု (မီလီမီတာ) အချက်အလက်တွေကို ထည့်လိုက်ရအောင်။ ၂၀၁၈, ၂၀၁၉, ၂၀၂၀ နှစ်တွေကို အာရုံစိုက်ပြီး တိုကျိုအတွက် ထည့်လိုက်ရင် အောက်ပါအတိုင်း ဖြစ်နိုင်ပါတယ်။

| မြို့   | နိုင်ငံ | နှစ်  | အရေအတွက် |
| ----- | ------- | ---- | ------ |
| တိုကျို | ဂျပန်   | ၂၀၂၀ | ၁၆၉၀   |
| တိုကျို | ဂျပန်   | ၂၀၁၉ | ၁၈၇၄   |
| တိုကျို | ဂျပန်   | ၂၀၁၈ | ၁၄၄၅   |

အတန်းကို ကြည့်ပြီး သတိထားမိတာရှိလား? မြို့နာမည်နဲ့ နိုင်ငံအချက်အလက်တွေကို ထပ်တလဲလဲ သိမ်းဆည်းထားတာကို သတိထားမိနိုင်ပါတယ်။ ဒါဟာ သိမ်းဆည်းမှုအများကြီးယူပြီး မလိုအပ်တဲ့ အချက်အလက်ထပ်နေမှုကို ဖြစ်စေပါတယ်။ တိုကျိုဟာ သက်ဆိုင်ရာနာမည်တစ်ခုသာရှိပါတယ်။

အခြားနည်းလမ်းကို ကြိုးစားကြည့်ရအောင်။ နှစ်စဉ်အတွက် ကော်လံအသစ်တွေကို ထည့်လိုက်ရအောင်။

| မြို့      | နိုင်ငံ          | ၂၀၁၈ | ၂၀၁၉ | ၂၀၂၀ |
| -------- | ------------- | ---- | ---- | ---- |
| တိုကျို   | ဂျပန်           | ၁၄၄၅ | ၁၈၇၄ | ၁၆၉၀ |
| အတ္လန်တာ | အမေရိကန်        | ၁၇၇၉ | ၁၁၁၁ | ၁၆၈၃ |
| အော့ကလန် | နယူးဇီလန်       | ၁၃၈၆ | ၉၄၂  | ၁၁၇၆ |

ဒါဟာ အတန်းထပ်နေမှုကို ရှောင်ရှားပေးနိုင်ပေမယ့် အခြားအခက်အခဲတွေကို ဖြစ်စေပါတယ်။ နှစ်အသစ်တစ်ခုရှိတိုင်း အတန်းဖွဲ့စည်းမှုကို ပြောင်းလဲဖို့ လိုအပ်ပါတယ်။ ဒါ့အပြင် ဒေတာတိုးလာတာနဲ့အမျှ နှစ်တွေကို ကော်လံအဖြစ်ထားရင် အချက်အလက်တွေကို ရှာဖွေခြင်းနဲ့ တွက်ချက်ခြင်းမှာ အခက်အခဲဖြစ်စေပါတယ်။

ဒါကြောင့် အတန်းများစွာနဲ့ ဆက်နွယ်မှုတွေလိုအပ်ပါတယ်။ ဒေတာကို ခွဲခြားထားခြင်းက ဒေတာထပ်နေမှုကို ရှောင်ရှားပြီး ဒေတာနဲ့ အလုပ်လုပ်တဲ့နည်းလမ်းမှာ ပိုမိုလွယ်ကူမှုရှိစေပါတယ်။

## ဆက်နွယ်မှုရဲ့ အယူအဆ

ဒေတာကို ပြန်လည်ကြည့်ပြီး ဘယ်လိုခွဲခြားထားမလဲ ဆုံးဖြတ်ကြရအောင်။ မြို့နာမည်နဲ့ နိုင်ငံကို သိမ်းဆည်းချင်တာကို သိပြီးသားဖြစ်တဲ့အတွက် ဒါကို အတန်းတစ်ခုမှာ သိမ်းဆည်းရမယ်။

| မြို့      | နိုင်ငံ          |
| -------- | ------------- |
| တိုကျို   | ဂျပန်           |
| အတ္လန်တာ | အမေရိကန်        |
| အော့ကလန် | နယူးဇီလန်       |

ဒါပေမယ့် နောက်ထပ်အတန်းကို ဖန်တီးမတိုင်မီ မြို့တစ်မြို့ကို ရည်ညွှန်းဖို့ နည်းလမ်းတစ်ခုလိုအပ်ပါတယ်။ ID သို့မဟုတ် (နည်းပညာဆိုင်ရာ ဒေတာဘေ့စ်အရ) primary key တစ်ခုလိုအပ်ပါတယ်။ primary key ဟာ အတန်းတစ်ခုစီကို သတ်မှတ်ပေးတဲ့ တန်ဖိုးတစ်ခုဖြစ်ပါတယ်။ ဒါဟာ တန်ဖိုးကို အခြေခံပြီး (ဥပမာ မြို့နာမည်ကို အသုံးပြုနိုင်ပါတယ်) သတ်မှတ်နိုင်ပေမယ့် အမြဲတမ်းနံပါတ် သို့မဟုတ် အခြား ID ဖြစ်သင့်ပါတယ်။ ID ဟာ ဘယ်တော့မှ မပြောင်းလဲသင့်ပါဘူး၊ ပြောင်းလဲရင် ဆက်နွယ်မှုကို ပျက်စီးစေမှာပါ။ အများအားဖြင့် primary key သို့မဟုတ် ID ဟာ auto-generated နံပါတ်ဖြစ်လေ့ရှိပါတယ်။

> ✅ Primary key ကို အတိုကောက် PK လို့ ခေါ်လေ့ရှိပါတယ်

### cities

| city_id | မြို့      | နိုင်ငံ          |
| ------- | -------- | ------------- |
| 1       | တိုကျို   | ဂျပန်           |
| 2       | အတ္လန်တာ | အမေရိကန်        |
| 3       | အော့ကလန် | နယူးဇီလန်       |

> ✅ ဒီသင်ခန်းစာအတွင်းမှာ "id" နဲ့ "primary key" ဆိုတဲ့ စကားလုံးတွေကို အလှည့်ကျ အသုံးပြုတာကို သတိထားမိပါလိမ့်မယ်။ ဒီအယူအဆတွေဟာ DataFrames တွေမှာလည်း သက်ဆိုင်ပါတယ်၊ သင်နောက်ပိုင်းမှာ DataFrames တွေကို လေ့လာပါမယ်။ DataFrames တွေမှာ "primary key" ဆိုတဲ့ စကားလုံးကို မသုံးပေမယ့် အတူတူပုံစံနဲ့ လုပ်ဆောင်တတ်ပါတယ်။

မြို့အတန်းကို ဖန်တီးပြီးရင် မိုးရွာသွန်းမှုကို သိမ်းဆည်းကြရအောင်။ မြို့အချက်အလက်ကို ထပ်မထားဘဲ ID ကို အသုံးပြုနိုင်ပါတယ်။ အသစ်ဖန်တီးထားတဲ့ အတန်းမှာလည်း *id* ကော်လံရှိသင့်ပါတယ်၊ အတန်းအားလုံးမှာ ID သို့မဟုတ် primary key ရှိသင့်ပါတယ်။

### rainfall

| rainfall_id | city_id | နှစ်  | အရေအတွက် |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | ၂၀၁၈ | ၁၄၄၅   |
| 2           | 1       | ၂၀၁၉ | ၁၈၇၄   |
| 3           | 1       | ၂၀၂၀ | ၁၆၉၀   |
| 4           | 2       | ၂၀၁၈ | ၁၇၇၉   |
| 5           | 2       | ၂၀၁၉ | ၁၁၁၁   |
| 6           | 2       | ၂၀၂၀ | ၁၆၈၃   |
| 7           | 3       | ၂၀၁၈ | ၁၃၈၆   |
| 8           | 3       | ၂၀၁၉ | ၉၄၂    |
| 9           | 3       | ၂၀၂၀ | ၁၁၇၆   |

အသစ်ဖန်တီးထားတဲ့ **rainfall** အတန်းထဲမှာ **city_id** ကော်လံကို သတိထားမိပါလိမ့်မယ်။ ဒီကော်လံဟာ **cities** အတန်းထဲက ID တွေကို ရည်ညွှန်းတဲ့ တန်ဖိုးတွေကို ပါဝင်ပါတယ်။ နည်းပညာဆိုင်ရာ ဆက်နွယ်မှုရှိတဲ့ ဒေတာအရ ဒီကို **foreign key** လို့ခေါ်ပါတယ်၊ ဒါဟာ အခြားအတန်းက primary key ဖြစ်ပါတယ်။ သင်က ဒါကို ရည်ညွှန်းချက် သို့မဟုတ် pointer လို့ပဲ ထင်ရပါမယ်။ **city_id** 1 ဟာ တိုကျိုကို ရည်ညွှန်းပါတယ်။

> [!NOTE] Foreign key ကို အတိုကောက် FK လို့ ခေါ်လေ့ရှိပါတယ်

## ဒေတာကို ရှာဖွေခြင်း

ဒေတာကို အတန်းနှစ်ခုခွဲထားပြီးနောက် ဒေတာကို ဘယ်လို ရှာဖွေမလဲ စဉ်းစားနိုင်ပါတယ်။ MySQL, SQL Server, Oracle တို့လို ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ကို အသုံးပြုရင် Structured Query Language (SQL) ဆိုတဲ့ ဘာသာစကားကို အသုံးပြုနိုင်ပါတယ်။ SQL (တစ်ခါတစ်ရံ sequel လို့လည်း ဖော်ပြတတ်ပါတယ်) ဟာ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ထဲမှာ ဒေတာကို ရှာဖွေခြင်းနဲ့ ပြင်ဆင်ခြင်းအတွက် အသုံးပြုတဲ့ စံဘာသာစကားဖြစ်ပါတယ်။

ဒေတာကို ရှာဖွေဖို့ `SELECT` ဆိုတဲ့ command ကို အသုံးပြုပါတယ်။ အခြေခံအားဖြင့် သင် **ကြည့်ချင်တဲ့ ကော်လံတွေကို** **အတန်းထဲက** ရွေးချယ်ပါတယ်။ မြို့နာမည်တွေကိုသာ ပြသချင်ရင် အောက်ပါအတိုင်း ရေးနိုင်ပါတယ်။

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` ဟာ သင်ကြည့်ချင်တဲ့ ကော်လံတွေကို ရေးတဲ့နေရာဖြစ်ပြီး `FROM` ဟာ အတန်းနာမည်ကို ရေးတဲ့နေရာဖြစ်ပါတယ်။

> [NOTE] SQL syntax ဟာ case-insensitive ဖြစ်ပါတယ်၊ `select` နဲ့ `SELECT` ဟာ တူတူပဲ။ ဒါပေမယ့် သင်အသုံးပြုတဲ့ ဒေတာဘေ့စ်အမျိုးအစားပေါ်မူတည်ပြီး ကော်လံနဲ့ အတန်းနာမည်တွေ case-sensitive ဖြစ်နိုင်ပါတယ်။ အဲ့ဒီအတွက် programming မှာ အားလုံးကို case-sensitive ဖြစ်တယ်လို့ ထင်ပြီး ရေးသားသင့်ပါတယ်။ SQL queries ရေးတဲ့အခါ keyword တွေကို အမြဲ uppercase နဲ့ ရေးသားတာဟာ အလေ့အထ ဖြစ်ပါတယ်။

အထက်ပါ query ဟာ မြို့အားလုံးကို ပြသပါမယ်။ နယူးဇီလန်မှာရှိတဲ့ မြို့တွေကိုသာ ပြသချင်ရင် filter တစ်ခုလိုအပ်ပါတယ်။ SQL keyword `WHERE` ကို အသုံးပြုရပါမယ်၊ ဒါဟာ "တစ်ခုခု true ဖြစ်တဲ့နေရာ" လို့ ဆိုလိုပါတယ်။

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## ဒေတာကို ပေါင်းစည်းခြင်း

အခုထိမှာတော့ အတန်းတစ်ခုထဲက ဒေတာကိုသာ ရှာဖွေခဲ့ပါတယ်။ အခုတော့ **cities** နဲ့ **rainfall** တို့ကနေ ဒေတာကို ပေါင်းစည်းချင်ပါတယ်။ ဒါကို *joining* လို့ခေါ်ပါတယ်။ သင် effectively အတန်းနှစ်ခုအကြား seam တစ်ခုဖန်တီးပြီး ကော်လံတစ်ခုစီက တန်ဖိုးတွေကို တွဲဖက်ပေးရပါမယ်။

ဥပမာမှာ **rainfall** ထဲက **city_id** ကို **cities** ထဲက **city_id** နဲ့ တွဲဖက်ပေးပါမယ်။ ဒါဟာ မိုးရွာသွန်းမှုတန်ဖိုးကို သက်ဆိုင်ရာ မြို့နဲ့ တွဲဖက်ပေးပါမယ်။ join လုပ်တဲ့အမျိုးအစားက *inner* join ဖြစ်ပြီး အတန်းတွေက တစ်ခုခုနဲ့ မကိုက်ညီရင် မပြသပါဘူး။ ငါတို့ရဲ့ ဥပမာမှာ မြို့တိုင်းမှာ မိုးရွာသွန်းမှုရှိတဲ့အတွက် အားလုံးကို ပြသပါမယ်။

မြို့အားလုံးအတွက် ၂၀၁၉ ခုနှစ် မိုးရွာသွန်းမှုကို ရှာဖွေကြရအောင်။

ဒီကို အဆင့်လိုက်လုပ်ဆောင်ပါမယ်။ ပထမအဆင့်က **city_id** ကော်လံကို seam အဖြစ် သတ်မှတ်ပြီး ဒေတာကို join လုပ်ပါမယ်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

သတ်မှတ်ထားတဲ့ ကော်လံနှစ်ခုကို highlight လုပ်ပြီး **city_id** ကို အသုံးပြုပြီး အတန်းတွေကို join လုပ်ချင်တယ်ဆိုတာ ဖော်ပြထားပါတယ်။ အခုတော့ `WHERE` statement ကို ထည့်ပြီး ၂၀၁၉ ခုနှစ်ကိုသာ filter လုပ်ပါမယ်။

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## အကျဉ်းချုပ်

ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်တွေဟာ အချက်အလက်တွေကို အတန်းများစွာအကြား ခွဲခြားထားပြီး ပြန်လည်ပေါင်းစည်းကာ ပြသခြင်းနဲ့ ခန့်မှန်းခြင်းအတွက် အသုံးပြုပါတယ်။ ဒါဟာ ဒေတာကို တွက်ချက်ခြင်းနဲ့ ပြင်ဆင်ခြင်းအတွက် အလွန် flexible ဖြစ်စေပါတယ်။ သင်ဟာ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်ရဲ့ အခြေခံအယူအဆတွေကို မြင်တွေ့ပြီး အတန်းနှစ်ခုအကြား join လုပ်တဲ့နည်းလမ်းကို လေ့လာခဲ့ပါတယ်။

## 🚀 စိန်ခေါ်မှု

အင်တာနက်ပေါ်မှာ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်များစွာ ရရှိနိုင်ပါတယ်။ သင်လေ့လာထားတဲ့ ကျွမ်းကျင်မှုတွေကို အသုံးပြုပြီး ဒေတာကို ရှာဖွေကြည့်နိုင်ပါတယ်။

## Post-Lecture Quiz

## [Post-lecture quiz](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## ပြန်လည်သုံးသပ်ခြင်းနှင့် ကိုယ်တိုင်လေ့လာခြင်း

SQL နဲ့ ဆက်နွယ်မှုရှိတဲ့ ဒေတာဘေ့စ်အယူအဆတွေကို ဆက်လက်လေ့လာဖို့ [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) မှာ အရင်းအမြစ်များစွာ ရရှိနိုင်ပါတယ်။

- [Describe concepts of relational data](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc

---

**အကြောင်းကြားချက်**:  
ဤစာရွက်စာတမ်းကို AI ဘာသာပြန်ဝန်ဆောင်မှု [Co-op Translator](https://github.com/Azure/co-op-translator) ကို အသုံးပြု၍ ဘာသာပြန်ထားပါသည်။ ကျွန်ုပ်တို့သည် တိကျမှုအတွက် ကြိုးစားနေသော်လည်း၊ အလိုအလျောက် ဘာသာပြန်မှုများတွင် အမှားများ သို့မဟုတ် မတိကျမှုများ ပါဝင်နိုင်သည်ကို သတိပြုပါ။ မူရင်းစာရွက်စာတမ်းကို ၎င်း၏ မူရင်းဘာသာစကားဖြင့် အာဏာတရားရှိသော အရင်းအမြစ်အဖြစ် ရှုလေ့လာသင့်ပါသည်။ အရေးကြီးသော အချက်အလက်များအတွက် လူ့ဘာသာပြန်ပညာရှင်များမှ ပရော်ဖက်ရှင်နယ် ဘာသာပြန်မှုကို အကြံပြုပါသည်။ ဤဘာသာပြန်မှုကို အသုံးပြုခြင်းမှ ဖြစ်ပေါ်လာသော အလွဲအလွတ်များ သို့မဟုတ် အနားလွဲမှုများအတွက် ကျွန်ုပ်တို့သည် တာဝန်မယူပါ။