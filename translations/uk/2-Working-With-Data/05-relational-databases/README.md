<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80d80300002ef4e77cc7631d5904bd6e",
  "translation_date": "2025-10-25T19:12:51+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "uk"
}
-->
# Робота з даними: реляційні бази даних

|![Скетчноут від [(@sketchthedocs)](https://sketchthedocs.dev)](../../sketchnotes/05-RelationalData.png)|
|:---:|
| Робота з даними: реляційні бази даних - _Скетчноут від [@nitya](https://twitter.com/nitya)_ |

Можливо, ви вже використовували електронні таблиці для зберігання інформації. У вас був набір рядків і стовпців, де рядки містили інформацію (або дані), а стовпці описували цю інформацію (іноді їх називають метаданими). Реляційна база даних побудована на цьому основному принципі стовпців і рядків у таблицях, що дозволяє зберігати інформацію в кількох таблицях. Це дає змогу працювати зі складнішими даними, уникати дублювання та мати гнучкість у дослідженні даних. Давайте розглянемо концепції реляційної бази даних.

## [Тест перед лекцією](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## Все починається з таблиць

У центрі реляційної бази даних знаходяться таблиці. Як і в електронній таблиці, таблиця — це набір стовпців і рядків. Рядок містить дані або інформацію, з якою ми хочемо працювати, наприклад, назву міста або кількість опадів. Стовпці описують дані, які вони зберігають.

Давайте почнемо дослідження, створивши таблицю для зберігання інформації про міста. Ми можемо почати з їхньої назви та країни. Ви можете зберегти це в таблиці наступним чином:

| Місто    | Країна        |
| -------- | ------------- |
| Токіо    | Японія        |
| Атланта  | Сполучені Штати |
| Окленд   | Нова Зеландія |

Зверніть увагу, що назви стовпців **місто**, **країна** та **населення** описують дані, які зберігаються, і кожен рядок містить інформацію про одне місто.

## Недоліки підходу з однією таблицею

Можливо, наведена вище таблиця здається вам досить знайомою. Давайте додамо деякі додаткові дані до нашої бази даних, що розвивається, — річну кількість опадів (у міліметрах). Ми зосередимося на роках 2018, 2019 і 2020. Якщо ми додамо дані для Токіо, це може виглядати приблизно так:

| Місто | Країна | Рік  | Кількість |
| ----- | ------- | ---- | -------- |
| Токіо | Японія  | 2020 | 1690     |
| Токіо | Японія  | 2019 | 1874     |
| Токіо | Японія  | 2018 | 1445     |

Що ви помітили в нашій таблиці? Ви могли помітити, що ми дублюємо назву та країну міста знову і знову. Це може займати досить багато місця і здебільшого є непотрібним. Зрештою, у Токіо є лише одна назва, яка нас цікавить.

Добре, спробуємо щось інше. Додамо нові стовпці для кожного року:

| Місто    | Країна        | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| Токіо    | Японія        | 1445 | 1874 | 1690 |
| Атланта  | Сполучені Штати | 1779 | 1111 | 1683 |
| Окленд   | Нова Зеландія | 1386 | 942  | 1176 |

Хоча це дозволяє уникнути дублювання рядків, це додає кілька інших проблем. Нам доведеться змінювати структуру нашої таблиці щоразу, коли з’являється новий рік. Крім того, коли наші дані зростають, використання років як стовпців ускладнить отримання та обчислення значень.

Ось чому нам потрібні кілька таблиць і зв’язки. Розділяючи наші дані, ми можемо уникнути дублювання та отримати більше гнучкості в роботі з даними.

## Концепція зв’язків

Повернемося до наших даних і визначимо, як ми хочемо їх розділити. Ми знаємо, що хочемо зберігати назву та країну для наших міст, тому це, мабуть, найкраще працюватиме в одній таблиці.

| Місто    | Країна        |
| -------- | ------------- |
| Токіо    | Японія        |
| Атланта  | Сполучені Штати |
| Окленд   | Нова Зеландія |

Але перед тим, як створити наступну таблицю, нам потрібно зрозуміти, як посилатися на кожне місто. Нам потрібен якийсь ідентифікатор, ID або (у технічних термінах бази даних) первинний ключ. Первинний ключ — це значення, яке використовується для ідентифікації одного конкретного рядка в таблиці. Хоча це може бути засноване на самому значенні (наприклад, ми могли б використовувати назву міста), це майже завжди має бути число або інший ідентифікатор. Ми не хочемо, щоб ідентифікатор змінювався, оскільки це порушить зв’язок. У більшості випадків первинний ключ або ідентифікатор буде автоматично згенерованим числом.

> ✅ Первинний ключ часто скорочується як PK

### міста

| city_id | Місто    | Країна        |
| ------- | -------- | ------------- |
| 1       | Токіо    | Японія        |
| 2       | Атланта  | Сполучені Штати |
| 3       | Окленд   | Нова Зеландія |

> ✅ Ви помітите, що ми використовуємо терміни "id" і "primary key" як взаємозамінні протягом цього уроку. Ці концепції також застосовуються до DataFrames, які ви будете досліджувати пізніше. DataFrames не використовують термінологію "primary key", однак ви помітите, що вони поводяться дуже схоже.

Після створення таблиці міст давайте збережемо дані про опади. Замість дублювання повної інформації про місто ми можемо використовувати id. Ми також повинні переконатися, що новостворена таблиця має стовпець *id*, оскільки всі таблиці повинні мати id або первинний ключ.

### опади

| rainfall_id | city_id | Рік  | Кількість |
| ----------- | ------- | ---- | -------- |
| 1           | 1       | 2018 | 1445     |
| 2           | 1       | 2019 | 1874     |
| 3           | 1       | 2020 | 1690     |
| 4           | 2       | 2018 | 1779     |
| 5           | 2       | 2019 | 1111     |
| 6           | 2       | 2020 | 1683     |
| 7           | 3       | 2018 | 1386     |
| 8           | 3       | 2019 | 942      |
| 9           | 3       | 2020 | 1176     |

Зверніть увагу на стовпець **city_id** у новоствореній таблиці **опади**. Цей стовпець містить значення, які посилаються на ID у таблиці **міста**. У технічних термінах реляційних даних це називається **зовнішнім ключем**; це первинний ключ з іншої таблиці. Ви можете просто думати про це як про посилання або покажчик. **city_id** 1 посилається на Токіо.

> [!NOTE] 
> Зовнішній ключ часто скорочується як FK

## Отримання даних

З нашими даними, розділеними на дві таблиці, ви можете запитати, як їх отримати. Якщо ми використовуємо реляційну базу даних, таку як MySQL, SQL Server або Oracle, ми можемо використовувати мову, яка називається Структурована мова запитів або SQL. SQL (іноді вимовляється як "сіквел") — це стандартна мова, яка використовується для отримання та модифікації даних у реляційній базі даних.

Щоб отримати дані, ви використовуєте команду `SELECT`. У її основі ви **вибираєте** стовпці, які хочете побачити, **з** таблиці, в якій вони містяться. Якщо ви хочете відобразити лише назви міст, ви можете використати наступне:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` — це місце, де ви перераховуєте стовпці, а `FROM` — це місце, де ви перераховуєте таблиці.

> [!NOTE] 
> Синтаксис SQL нечутливий до регістру, тобто `select` і `SELECT` означають одне й те саме. Однак, залежно від типу бази даних, яку ви використовуєте, стовпці та таблиці можуть бути чутливими до регістру. Тому найкраща практика — завжди ставитися до всього в програмуванні так, ніби це чутливе до регістру. Під час написання SQL-запитів загальноприйнято писати ключові слова великими літерами.

Запит вище відобразить усі міста. Уявімо, що ми хочемо відобразити лише міста в Новій Зеландії. Нам потрібен якийсь фільтр. Ключове слово SQL для цього — `WHERE`, або "де щось є правдою".

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## Об'єднання даних

До цього моменту ми отримували дані лише з однієї таблиці. Тепер ми хочемо об'єднати дані з таблиць **міста** та **опади**. Це робиться шляхом *об'єднання* їх разом. Ви фактично створите шов між двома таблицями та зіставите значення зі стовпця кожної таблиці.

У нашому прикладі ми зіставимо стовпець **city_id** у **опади** зі стовпцем **city_id** у **міста**. Це зіставить значення опадів із відповідним містом. Тип об'єднання, який ми виконаємо, називається *внутрішнім* об'єднанням, тобто якщо будь-які рядки не відповідають нічому з іншої таблиці, вони не будуть відображатися. У нашому випадку кожне місто має дані про опади, тому все буде відображено.

Давайте отримаємо дані про опади за 2019 рік для всіх наших міст.

Ми будемо робити це поетапно. Перший крок — об'єднати дані, вказавши стовпці для шва — **city_id**, як зазначено раніше.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

Ми виділили два стовпці, які нам потрібні, і факт, що ми хочемо об'єднати таблиці за **city_id**. Тепер ми можемо додати оператор `WHERE`, щоб відфільтрувати лише рік 2019.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## Підсумок

Реляційні бази даних зосереджені на розділенні інформації між кількома таблицями, які потім об'єднуються для відображення та аналізу. Це забезпечує високий ступінь гнучкості для виконання обчислень та інших маніпуляцій з даними. Ви ознайомилися з основними концепціями реляційної бази даних і тим, як виконувати об'єднання між двома таблицями.

## 🚀 Виклик

Існує багато реляційних баз даних, доступних в Інтернеті. Ви можете досліджувати дані, використовуючи навички, які ви засвоїли вище.

## Тест після лекції

## [Тест після лекції](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## Огляд і самостійне навчання

На [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) доступно кілька ресурсів, які допоможуть вам продовжити вивчення SQL і концепцій реляційних баз даних.

- [Опис концепцій реляційних даних](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Початок роботи з запитами в Transact-SQL](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL — це версія SQL)
- [Контент SQL на Microsoft Learn](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## Завдання

[Назва завдання](assignment.md)

---

**Відмова від відповідальності**:  
Цей документ був перекладений за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, будь ласка, майте на увазі, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ на його рідній мові слід вважати авторитетним джерелом. Для критичної інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникають внаслідок використання цього перекладу.