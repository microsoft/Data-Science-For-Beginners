<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "9399d7b4767e75068f95ce5c660b285c",
  "translation_date": "2025-09-05T18:40:44+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "bg"
}
-->
# Работа с данни: Релационни бази данни

|![ Скетч от [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| Работа с данни: Релационни бази данни - _Скетч от [@nitya](https://twitter.com/nitya)_ |

Вероятно сте използвали електронна таблица в миналото, за да съхранявате информация. Имахте набор от редове и колони, където редовете съдържаха информацията (или данните), а колоните описваха информацията (понякога наричана метаданни). Релационната база данни е изградена върху този основен принцип на колони и редове в таблици, което ви позволява да разпределите информацията в множество таблици. Това ви дава възможност да работите с по-сложни данни, да избегнете дублирането и да имате гъвкавост в начина, по който изследвате данните. Нека разгледаме концепциите на релационната база данни.

## [Тест преди лекцията](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## Всичко започва с таблици

В основата на релационната база данни са таблиците. Точно както при електронната таблица, таблицата е колекция от колони и редове. Редът съдържа данните или информацията, с която искаме да работим, като например името на град или количеството валежи. Колоните описват данните, които съхраняват.

Нека започнем нашето изследване, като създадем таблица за съхранение на информация за градове. Може да започнем с техните имена и държави. Можете да съхранявате това в таблица, както следва:

| Град     | Държава       |
| -------- | ------------- |
| Токио    | Япония        |
| Атланта  | Съединени щати |
| Окланд   | Нова Зеландия |

Забележете, че имената на колоните **град**, **държава** и **население** описват данните, които се съхраняват, а всеки ред съдържа информация за един град.

## Недостатъци на подхода с една таблица

Вероятно таблицата по-горе ви изглежда сравнително позната. Нека започнем да добавяме допълнителни данни към нашата разрастваща се база данни - годишни валежи (в милиметри). Ще се фокусираме върху годините 2018, 2019 и 2020. Ако трябваше да добавим данни за Токио, това може да изглежда така:

| Град  | Държава | Година | Количество |
| ----- | ------- | ------ | ---------- |
| Токио | Япония  | 2020   | 1690       |
| Токио | Япония  | 2019   | 1874       |
| Токио | Япония  | 2018   | 1445       |

Какво забелязвате в нашата таблица? Може да забележите, че дублираме името и държавата на града отново и отново. Това може да заема доста място за съхранение и е до голяма степен ненужно да имаме множество копия. В крайна сметка, Токио има само едно име, което ни интересува.

Добре, нека опитаме нещо друго. Нека добавим нови колони за всяка година:

| Град     | Държава       | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| Токио    | Япония        | 1445 | 1874 | 1690 |
| Атланта  | Съединени щати | 1779 | 1111 | 1683 |
| Окланд   | Нова Зеландия | 1386 | 942  | 1176 |

Докато това избягва дублирането на редове, то добавя няколко други предизвикателства. Ще трябва да променяме структурата на нашата таблица всеки път, когато има нова година. Освен това, когато данните ни растат, наличието на години като колони ще направи по-трудно извличането и изчисляването на стойности.

Ето защо ни трябват множество таблици и връзки. Чрез разделяне на данните можем да избегнем дублирането и да имаме повече гъвкавост в начина, по който работим с тях.

## Концепцията за връзки

Нека се върнем към нашите данни и определим как искаме да ги разделим. Знаем, че искаме да съхраняваме името и държавата на нашите градове, така че това вероятно ще работи най-добре в една таблица.

| Град     | Държава       |
| -------- | ------------- |
| Токио    | Япония        |
| Атланта  | Съединени щати |
| Окланд   | Нова Зеландия |

Но преди да създадем следващата таблица, трябва да измислим как да реферираме всеки град. Нуждаем се от някаква форма на идентификатор, ID или (в технически термини за бази данни) първичен ключ. Първичният ключ е стойност, използвана за идентифициране на един конкретен ред в таблица. Въпреки че това може да се базира на самата стойност (можем да използваме името на града, например), почти винаги трябва да бъде число или друг идентификатор. Не искаме ID да се променя, тъй като това би нарушило връзката. В повечето случаи първичният ключ или ID ще бъде автоматично генерирано число.

> ✅ Първичният ключ често се съкращава като PK

### градове

| city_id | Град     | Държава       |
| ------- | -------- | ------------- |
| 1       | Токио    | Япония        |
| 2       | Атланта  | Съединени щати |
| 3       | Окланд   | Нова Зеландия |

> ✅ Ще забележите, че използваме термините "id" и "първичен ключ" взаимозаменяемо по време на този урок. Концепциите тук се прилагат и за DataFrames, които ще разгледате по-късно. DataFrames не използват терминологията "първичен ключ", но ще забележите, че се държат по подобен начин.

Създавайки нашата таблица за градове, нека съхраним данните за валежите. Вместо да дублираме пълната информация за града, можем да използваме ID. Също така трябва да се уверим, че новосъздадената таблица има *id* колона, тъй като всички таблици трябва да имат ID или първичен ключ.

### валежи

| rainfall_id | city_id | Година | Количество |
| ----------- | ------- | ------ | ---------- |
| 1           | 1       | 2018   | 1445       |
| 2           | 1       | 2019   | 1874       |
| 3           | 1       | 2020   | 1690       |
| 4           | 2       | 2018   | 1779       |
| 5           | 2       | 2019   | 1111       |
| 6           | 2       | 2020   | 1683       |
| 7           | 3       | 2018   | 1386       |
| 8           | 3       | 2019   | 942        |
| 9           | 3       | 2020   | 1176       |

Забележете колоната **city_id** в новосъздадената таблица **валежи**. Тази колона съдържа стойности, които реферират ID-тата в таблицата **градове**. В технически термини за релационни данни това се нарича **външен ключ**; това е първичен ключ от друга таблица. Можете просто да го мислите като референция или указател. **city_id** 1 реферира към Токио.

> [!NOTE] Външният ключ често се съкращава като FK

## Извличане на данни

С разделените данни в две таблици, може би се чудите как да ги извлечем. Ако използваме релационна база данни като MySQL, SQL Server или Oracle, можем да използваме език, наречен Структуриран език за заявки или SQL. SQL (понякога произнасяно като "сикъл") е стандартен език, използван за извличане и модифициране на данни в релационна база данни.

За да извлечете данни, използвате командата `SELECT`. В основата си, вие **избирате** колоните, които искате да видите **от** таблицата, в която се съдържат. Ако искате да покажете само имената на градовете, можете да използвате следното:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` е мястото, където изброявате колоните, а `FROM` е мястото, където изброявате таблиците.

> [NOTE] Синтаксисът на SQL не прави разлика между малки и големи букви, което означава, че `select` и `SELECT` означават едно и също. Въпреки това, в зависимост от типа база данни, която използвате, колоните и таблиците може да правят разлика между малки и големи букви. Затова е добра практика винаги да третирате всичко в програмирането като чувствително към малки и големи букви. При писане на SQL заявки обичайно е ключовите думи да се пишат с главни букви.

Горната заявка ще покаже всички градове. Да си представим, че искаме да покажем само градовете в Нова Зеландия. Нуждаем се от някаква форма на филтър. SQL ключовата дума за това е `WHERE`, или "където нещо е вярно".

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## Свързване на данни

Досега извличахме данни от една таблица. Сега искаме да обединим данните от **градове** и **валежи**. Това се прави чрез *свързване* на таблиците. Ефективно ще създадете връзка между двете таблици и ще съпоставите стойностите от колона от всяка таблица.

В нашия пример ще съпоставим колоната **city_id** в **валежи** с колоната **city_id** в **градове**. Това ще съпостави стойността на валежите със съответния град. Типът свързване, който ще извършим, се нарича *вътрешно* свързване, което означава, че ако някои редове не съвпадат с нищо от другата таблица, те няма да бъдат показани. В нашия случай всеки град има данни за валежи, така че всичко ще бъде показано.

Нека извлечем данните за валежите през 2019 г. за всички наши градове.

Ще направим това на стъпки. Първата стъпка е да свържем данните, като посочим колоните за връзката - **city_id**, както беше подчертано преди.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

Подчертали сме двете колони, които искаме, и факта, че искаме да свържем таблиците чрез **city_id**. Сега можем да добавим израза `WHERE`, за да филтрираме само годината 2019.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## Обобщение

Релационните бази данни са съсредоточени около разделянето на информацията между множество таблици, които след това се обединяват за показване и анализ. Това предоставя висока степен на гъвкавост за извършване на изчисления и други манипулации на данни. Видяхте основните концепции на релационната база данни и как да извършите свързване между две таблици.

## 🚀 Предизвикателство

Има множество релационни бази данни, достъпни в интернет. Можете да изследвате данните, използвайки уменията, които научихте по-горе.

## Тест след лекцията

## [Тест след лекцията](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## Преглед и самостоятелно обучение

Има няколко ресурса, достъпни на [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum), за да продължите вашето изследване на SQL и концепциите за релационни бази данни:

- [Описание на концепциите за релационни данни](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Започнете с заявки с Transact-SQL](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL е версия на SQL)
- [SQL съдържание на Microsoft Learn](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## Задание

[Заглавие на заданието](assignment.md)

---

**Отказ от отговорност**:  
Този документ е преведен с помощта на AI услуга за превод [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматизираните преводи може да съдържат грешки или неточности. Оригиналният документ на неговия роден език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален човешки превод. Не носим отговорност за недоразумения или погрешни интерпретации, произтичащи от използването на този превод.