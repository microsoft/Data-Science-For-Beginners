<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80d80300002ef4e77cc7631d5904bd6e",
  "translation_date": "2025-10-25T18:45:02+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "mr"
}
-->
# डेटासह कार्य करणे: रिलेशनल डेटाबेस

|![ [(@sketchthedocs)](https://sketchthedocs.dev) द्वारे स्केच नोट ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| डेटासह कार्य करणे: रिलेशनल डेटाबेस - _[@nitya](https://twitter.com/nitya) द्वारे स्केच नोट_ |

तुम्ही पूर्वी माहिती साठवण्यासाठी स्प्रेडशीट वापरले असेल अशी शक्यता आहे. तुमच्याकडे पंक्ती आणि स्तंभांचा संच होता, जिथे पंक्तींमध्ये माहिती (किंवा डेटा) असतो आणि स्तंभांमध्ये माहितीचे वर्णन केले जाते (कधीकधी मेटाडेटा म्हणतात). रिलेशनल डेटाबेस टेबल्समधील पंक्ती आणि स्तंभांच्या या मुख्य तत्त्वावर आधारित आहे, ज्यामुळे तुम्हाला अनेक टेबल्समध्ये माहिती पसरवता येते. यामुळे तुम्हाला अधिक जटिल डेटासह काम करणे, पुनरावृत्ती टाळणे आणि डेटा एक्सप्लोर करण्याच्या पद्धतींमध्ये लवचिकता मिळते. चला रिलेशनल डेटाबेसच्या संकल्पनांचा अभ्यास करूया.

## [पूर्व-व्याख्यान प्रश्नमंजूषा](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## सर्व काही टेबल्सपासून सुरू होते

रिलेशनल डेटाबेसच्या केंद्रस्थानी टेबल्स असतात. स्प्रेडशीटप्रमाणेच, टेबल हा स्तंभ आणि पंक्तींचा संग्रह आहे. पंक्तीमध्ये आपल्याला काम करायचा डेटा किंवा माहिती असते, जसे की शहराचे नाव किंवा पावसाचे प्रमाण. स्तंभ साठवलेल्या डेटाचे वर्णन करतात.

चला शहरांबद्दल माहिती साठवण्यासाठी टेबल तयार करून आपला अभ्यास सुरू करूया. आपण त्यांच्या नाव आणि देशासह सुरुवात करू शकतो. तुम्ही हे खालीलप्रमाणे टेबलमध्ये साठवू शकता:

| शहर      | देश           |
| -------- | ------------- |
| टोकियो   | जपान          |
| अटलांटा  | युनायटेड स्टेट्स |
| ऑकलंड    | न्यूझीलंड      |

लक्षात घ्या की **शहर**, **देश** आणि **लोकसंख्या** या स्तंभांची नावे साठवलेल्या डेटाचे वर्णन करतात आणि प्रत्येक पंक्तीत एका शहराची माहिती आहे.

## एकाच टेबल पद्धतीची मर्यादा

वर दिलेले टेबल तुम्हाला तुलनेने परिचित वाटत असेल. चला आपल्या वाढत्या डेटाबेसमध्ये काही अतिरिक्त डेटा जोडूया - वार्षिक पाऊस (मिलीमीटरमध्ये). आपण 2018, 2019 आणि 2020 या वर्षांवर लक्ष केंद्रित करू. जर आपण टोकियोसाठी ते जोडले तर ते असे दिसेल:

| शहर   | देश     | वर्ष | प्रमाण |
| ----- | ------- | ---- | ------ |
| टोकियो | जपान   | 2020 | 1690   |
| टोकियो | जपान   | 2019 | 1874   |
| टोकियो | जपान   | 2018 | 1445   |

आपण आमच्या टेबलबद्दल काय लक्षात घेतले? तुम्हाला कदाचित लक्षात येईल की आम्ही शहराचे नाव आणि देश पुन्हा पुन्हा डुप्लिकेट करत आहोत. यामुळे बरीच स्टोरेज लागेल आणि अनेक प्रत असणे अनावश्यक आहे. शेवटी, टोकियोला फक्त एकच नाव आहे ज्यामध्ये आपल्याला रस आहे.

ठीक आहे, काहीतरी वेगळे प्रयत्न करूया. प्रत्येक वर्षासाठी नवीन स्तंभ जोडूया:

| शहर      | देश           | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| टोकियो   | जपान          | 1445 | 1874 | 1690 |
| अटलांटा  | युनायटेड स्टेट्स | 1779 | 1111 | 1683 |
| ऑकलंड    | न्यूझीलंड      | 1386 | 942  | 1176 |

जरी यामुळे पंक्तींची पुनरावृत्ती टळते, तरीही यामुळे इतर काही आव्हाने निर्माण होतात. प्रत्येक वेळी नवीन वर्ष असताना आपल्याला आपल्या टेबलची रचना बदलावी लागेल. याशिवाय, आपला डेटा वाढत असताना, आपल्या वर्षे स्तंभ म्हणून ठेवणे मूल्ये पुनर्प्राप्त करणे आणि गणना करणे अधिक कठीण करेल.

म्हणूनच आपल्याला एकाधिक टेबल्स आणि नातेसंबंधांची आवश्यकता आहे. आपला डेटा विभाजित करून आपण पुनरावृत्ती टाळू शकतो आणि आपल्या डेटासह कसे काम करायचे यामध्ये अधिक लवचिकता मिळवू शकतो.

## नातेसंबंधांची संकल्पना

चला आपल्या डेटावर परत जाऊया आणि ते कसे विभाजित करायचे ते ठरवूया. आपल्याला आपल्या शहरांची नाव आणि देश साठवायची आहेत हे आपल्याला माहित आहे, त्यामुळे हे एका टेबलमध्ये चांगले काम करेल.

| शहर      | देश           |
| -------- | ------------- |
| टोकियो   | जपान          |
| अटलांटा  | युनायटेड स्टेट्स |
| ऑकलंड    | न्यूझीलंड      |

पण पुढील टेबल तयार करण्यापूर्वी, आपल्याला प्रत्येक शहराचा संदर्भ कसा द्यायचा ते शोधणे आवश्यक आहे. आपल्याला काही प्रकारचा ओळखकर्ता, आयडी किंवा (तांत्रिक डेटाबेस अटींमध्ये) प्राथमिक की आवश्यक आहे. प्राथमिक की ही एक विशिष्ट पंक्ती ओळखण्यासाठी वापरली जाणारी मूल्य आहे. जरी हे स्वतः मूल्यावर आधारित असू शकते (उदाहरणार्थ, आपण शहराचे नाव वापरू शकतो), तरीही ते जवळजवळ नेहमीच एक संख्या किंवा इतर ओळखकर्ता असावे. आम्हाला आयडी कधीही बदलायचा नाही कारण यामुळे नातेसंबंध तुटेल. तुम्हाला बहुतेक प्रकरणांमध्ये आढळेल की प्राथमिक की किंवा आयडी ही स्वयंचलितपणे तयार केलेली संख्या असेल.

> ✅ प्राथमिक कीला वारंवार PK म्हणून संक्षेपित केले जाते

### शहर

| city_id | शहर      | देश           |
| ------- | -------- | ------------- |
| 1       | टोकियो   | जपान          |
| 2       | अटलांटा  | युनायटेड स्टेट्स |
| 3       | ऑकलंड    | न्यूझीलंड      |

> ✅ तुम्ही लक्षात घ्याल की आम्ही या धड्यादरम्यान "id" आणि "primary key" या संज्ञा परस्पर बदलून वापरतो. येथे दिलेली संकल्पना DataFrames वर लागू होते, ज्याचा तुम्ही नंतर अभ्यास कराल. DataFrames "primary key" ची संज्ञा वापरत नाहीत, परंतु तुम्ही लक्षात घ्याल की ते जवळजवळ त्याच प्रकारे वागतात.

आपले शहरांचे टेबल तयार झाल्यावर, चला पावसाचे प्रमाण साठवूया. शहराबद्दलची संपूर्ण माहिती डुप्लिकेट करण्याऐवजी, आपण आयडी वापरू शकतो. आम्ही देखील सुनिश्चित केले पाहिजे की नव्याने तयार केलेल्या टेबलमध्ये *id* स्तंभ आहे, कारण सर्व टेबल्समध्ये आयडी किंवा प्राथमिक की असावी.

### पाऊस

| rainfall_id | city_id | वर्ष | प्रमाण |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

नव्याने तयार केलेल्या **rainfall** टेबलमधील **city_id** स्तंभ लक्षात घ्या. या स्तंभात **cities** टेबलमधील आयडी संदर्भित करणारी मूल्ये आहेत. तांत्रिक रिलेशनल डेटा अटींमध्ये, याला **foreign key** म्हणतात; हे दुसऱ्या टेबलमधील प्राथमिक की आहे. तुम्ही फक्त याचा संदर्भ किंवा पॉइंटर म्हणून विचार करू शकता. **city_id** 1 टोकियोला संदर्भित करते.

> [!NOTE] 
> Foreign key ला वारंवार FK म्हणून संक्षेपित केले जाते

## डेटा पुनर्प्राप्त करणे

आपला डेटा दोन टेबल्समध्ये विभाजित केल्यावर, तुम्हाला आश्चर्य वाटेल की आपण तो कसा पुनर्प्राप्त करू. जर आपण MySQL, SQL Server किंवा Oracle सारख्या रिलेशनल डेटाबेसचा वापर करत असाल, तर आपण Structured Query Language किंवा SQL नावाची भाषा वापरू शकतो. SQL (कधीकधी sequel असे उच्चारले जाते) ही रिलेशनल डेटाबेसमधील डेटा पुनर्प्राप्त करण्यासाठी आणि बदलण्यासाठी वापरली जाणारी मानक भाषा आहे.

डेटा पुनर्प्राप्त करण्यासाठी तुम्ही `SELECT` कमांड वापरता. त्याच्या केंद्रस्थानी, तुम्ही **select** स्तंभांची यादी करता जे तुम्हाला **from** टेबलमध्ये पाहायचे आहेत. जर तुम्हाला फक्त शहरांची नावे प्रदर्शित करायची असतील, तर तुम्ही खालीलप्रमाणे वापरू शकता:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` ही जिथे तुम्ही स्तंभांची यादी करता आणि `FROM` ही जिथे तुम्ही टेबलांची यादी करता.

> [!NOTE] 
> SQL सिंटॅक्स केस-इन्सेन्सिटिव्ह आहे, म्हणजेच `select` आणि `SELECT` याचा एकच अर्थ आहे. तथापि, तुम्ही वापरत असलेल्या डेटाबेसच्या प्रकारानुसार स्तंभ आणि टेबल्स केस सेंसिटिव्ह असू शकतात. परिणामी, प्रोग्रामिंगमध्ये सर्वकाही केस सेंसिटिव्ह असल्यासारखे वागवणे ही सर्वोत्तम पद्धत आहे. SQL क्वेरी लिहिताना सामान्य प्रथा म्हणजे कीवर्ड्स सर्व मोठ्या अक्षरांमध्ये लिहिणे.

वरील क्वेरी सर्व शहरांचे प्रदर्शन करेल. कल्पना करा की आम्हाला फक्त न्यूझीलंडमधील शहरांचे प्रदर्शन करायचे आहे. आपल्याला काही प्रकारचे फिल्टर आवश्यक आहे. यासाठी SQL कीवर्ड `WHERE` आहे, म्हणजे "काहीतरी खरे आहे तिथे".

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## डेटा जोडणे

आतापर्यंत आपण एका टेबलमधून डेटा पुनर्प्राप्त केला आहे. आता आम्हाला **cities** आणि **rainfall** या दोन्ही टेबल्समधील डेटा एकत्र आणायचा आहे. हे त्यांना एकत्र *जोडून* केले जाते. तुम्ही प्रभावीपणे दोन टेबल्समधील एका स्तंभातून मूल्ये जुळवून एक सीम तयार कराल.

आमच्या उदाहरणात, आम्ही **rainfall** मधील **city_id** स्तंभ **cities** मधील **city_id** स्तंभासह जुळवू. यामुळे पावसाचे मूल्य त्याच्या संबंधित शहराशी जुळेल. आपण करणार असलेल्या जॉइनचा प्रकार *inner* जॉइन म्हणतात, म्हणजे जर कोणत्याही पंक्ती दुसऱ्या टेबलमधील कोणत्याही गोष्टीशी जुळत नसतील तर त्या प्रदर्शित केल्या जाणार नाहीत. आमच्या बाबतीत प्रत्येक शहराला पाऊस आहे, त्यामुळे सर्व काही प्रदर्शित केले जाईल.

चला 2019 साठी सर्व शहरांसाठी पावसाचे प्रमाण पुनर्प्राप्त करूया.

आम्ही हे टप्प्याटप्प्याने करू. पहिला टप्पा म्हणजे **city_id** स्तंभाद्वारे सीम दर्शवून डेटा एकत्र जोडणे.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

आम्ही दोन स्तंभ हायलाइट केले आहेत जे आम्हाला हवे आहेत आणि आम्हाला **city_id** द्वारे टेबल्स एकत्र जोडायचे आहेत. आता आम्ही फक्त 2019 वर्ष फिल्टर करण्यासाठी `WHERE` स्टेटमेंट जोडू शकतो.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## सारांश

रिलेशनल डेटाबेस अनेक टेबल्समध्ये माहिती विभागण्यावर केंद्रित असतात, जी नंतर प्रदर्शन आणि विश्लेषणासाठी पुन्हा एकत्र आणली जाते. यामुळे गणना करण्यासाठी आणि अन्यथा डेटा हाताळण्यासाठी उच्च स्तराची लवचिकता प्रदान होते. तुम्ही रिलेशनल डेटाबेसच्या मुख्य संकल्पना पाहिल्या आहेत आणि दोन टेबल्समधील जॉइन कसे करावे ते शिकले आहे.

## 🚀 आव्हान

इंटरनेटवर अनेक रिलेशनल डेटाबेस उपलब्ध आहेत. तुम्ही वरील शिकलेल्या कौशल्यांचा वापर करून डेटा एक्सप्लोर करू शकता.

## व्याख्यानानंतरची प्रश्नमंजूषा

## [व्याख्यानानंतरची प्रश्नमंजूषा](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## पुनरावलोकन आणि स्व-अभ्यास

SQL आणि रिलेशनल डेटाबेस संकल्पनांचा अभ्यास सुरू ठेवण्यासाठी [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) वर अनेक संसाधने उपलब्ध आहेत.

- [रिलेशनल डेटाच्या संकल्पना वर्णन करा](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Transact-SQL सह क्वेरींग सुरू करा](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL ही SQL ची आवृत्ती आहे)
- [Microsoft Learn वर SQL सामग्री](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## असाइनमेंट

[असाइनमेंट शीर्षक](assignment.md)

---

**अस्वीकरण**:  
हा दस्तऐवज AI भाषांतर सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) वापरून भाषांतरित करण्यात आला आहे. आम्ही अचूकतेसाठी प्रयत्नशील असलो तरी, कृपयास लक्षात ठेवा की स्वयंचलित भाषांतरे त्रुटी किंवा अचूकतेच्या अभावाने युक्त असू शकतात. मूळ भाषेतील दस्तऐवज हा अधिकृत स्रोत मानला जावा. महत्त्वाच्या माहितीसाठी व्यावसायिक मानवी भाषांतराची शिफारस केली जाते. या भाषांतराचा वापर करून उद्भवलेल्या कोणत्याही गैरसमज किंवा चुकीच्या अर्थासाठी आम्ही जबाबदार राहणार नाही.