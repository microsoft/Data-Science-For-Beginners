<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "1b560955ff39a2bcf2a049fce474a951",
  "translation_date": "2025-09-06T07:27:48+00:00",
  "source_file": "2-Working-With-Data/08-data-preparation/README.md",
  "language_code": "mr"
}
-->
# डेटा सोबत काम करणे: डेटा तयारी

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/08-DataPreparation.png)|
|:---:|
|डेटा तयारी - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

## [पूर्व-व्याख्यान क्विझ](https://ff-quizzes.netlify.app/en/ds/quiz/14)

डेटाचा स्रोत कोणताही असो, कच्च्या डेटामध्ये काही विसंगती असू शकतात ज्यामुळे विश्लेषण आणि मॉडेलिंगमध्ये अडचणी निर्माण होतात. दुसऱ्या शब्दांत, हा डेटा "गलिच्छ" म्हणून वर्गीकृत केला जाऊ शकतो आणि त्याला स्वच्छ करण्याची गरज असते. या धड्यात डेटा स्वच्छ करण्याच्या आणि बदलण्याच्या तंत्रांवर लक्ष केंद्रित केले आहे, ज्यामुळे हरवलेला, अचूक नसलेला किंवा अपूर्ण डेटा हाताळता येतो. या धड्यात समाविष्ट केलेल्या विषयांमध्ये Python आणि Pandas लायब्ररीचा वापर केला जाईल आणि [नोटबुकमध्ये दाखवले जाईल](../../../../2-Working-With-Data/08-data-preparation/notebook.ipynb) या डिरेक्टरीमध्ये.

## डेटा स्वच्छ करण्याचे महत्त्व

- **वापरण्याची आणि पुन्हा वापरण्याची सोय**: जेव्हा डेटा व्यवस्थितपणे आयोजित आणि सामान्यीकृत केला जातो, तेव्हा तो शोधणे, वापरणे आणि इतरांसोबत शेअर करणे सोपे होते.

- **सुसंगतता**: डेटा सायन्समध्ये अनेकदा एकापेक्षा जास्त डेटासेट्ससोबत काम करावे लागते, जिथे वेगवेगळ्या स्रोतांमधील डेटासेट्स एकत्र जोडले जातात. प्रत्येक स्वतंत्र डेटासेटमध्ये सामान्य मानकीकरण सुनिश्चित केल्याने, ते सर्व एकत्रित केल्यावर डेटा उपयुक्त राहील.

- **मॉडेल अचूकता**: स्वच्छ केलेला डेटा मॉडेल्सची अचूकता सुधारतो, जे त्यावर अवलंबून असतात.

## सामान्य स्वच्छता उद्दिष्टे आणि रणनीती

- **डेटासेट एक्सप्लोर करणे**: डेटा एक्सप्लोरेशन, ज्यावर [नंतरच्या धड्यात](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/4-Data-Science-Lifecycle/15-analyzing) चर्चा केली जाते, तुम्हाला स्वच्छ करायची गरज असलेला डेटा शोधण्यात मदत करू शकते. डेटासेटमधील मूल्ये व्हिज्युअली पाहणे तुम्हाला उर्वरित डेटाबद्दल अपेक्षा सेट करण्यात किंवा सोडवता येणाऱ्या समस्यांची कल्पना देण्यात मदत करू शकते. एक्सप्लोरेशनमध्ये मूलभूत क्वेरी करणे, व्हिज्युअलायझेशन आणि सॅम्पलिंग समाविष्ट असते.

- **फॉरमॅटिंग**: स्रोतावर अवलंबून, डेटामध्ये सादरीकरणाच्या पद्धतीत विसंगती असू शकते. यामुळे डेटासेटमध्ये मूल्य शोधण्यात आणि सादर करण्यात अडचणी येऊ शकतात, जिथे ते दिसते पण व्हिज्युअलायझेशन किंवा क्वेरी परिणामांमध्ये योग्य प्रकारे सादर केले जात नाही. सामान्य फॉरमॅटिंग समस्यांमध्ये व्हाइटस्पेस, तारीख आणि डेटा प्रकार सोडवणे समाविष्ट आहे. फॉरमॅटिंग समस्या सोडवणे हे सामान्यतः डेटा वापरणाऱ्या लोकांवर अवलंबून असते. उदाहरणार्थ, तारीख आणि संख्या कशा सादर केल्या जातात यावर देशानुसार मानके वेगवेगळी असू शकतात.

- **डुप्लिकेशन**: डेटा ज्यामध्ये एकापेक्षा जास्त घटना असतात, तो अचूक परिणाम तयार करू शकतो आणि सामान्यतः काढून टाकला पाहिजे. दोन किंवा अधिक डेटासेट्स एकत्र जोडताना हे सामान्यतः घडते. तथापि, अशा उदाहरणे असू शकतात जिथे जोडलेल्या डेटासेट्समधील डुप्लिकेशनमध्ये अतिरिक्त माहिती असते आणि ती जतन करणे आवश्यक असते.

- **हरवलेला डेटा**: हरवलेला डेटा अचूकतेसह कमकुवत किंवा पक्षपाती परिणाम निर्माण करू शकतो. कधी कधी हे डेटा "पुन्हा लोड" करून, हरवलेल्या मूल्यांना गणना आणि कोडसह भरून किंवा फक्त मूल्य आणि संबंधित डेटा काढून टाकून सोडवले जाऊ शकते. डेटा का आणि कसा हरवला गेला यावर आधारित, हरवलेल्या मूल्यांना सोडवण्यासाठी घेतलेली कृती वेगवेगळी असू शकते.

## DataFrame माहिती एक्सप्लोर करणे
> **शिकण्याचे उद्दिष्ट:** या उपविभागाच्या शेवटी, तुम्ही pandas DataFrames मध्ये संग्रहित डेटाबद्दल सामान्य माहिती शोधण्यात आरामदायक असले पाहिजे.

तुम्ही तुमचा डेटा pandas मध्ये लोड केल्यानंतर, तो DataFrame मध्ये असण्याची शक्यता जास्त आहे (मागील [धडा](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/2-Working-With-Data/07-python#dataframe) साठी तपशीलवार विहंगावलोकन पहा). तथापि, जर तुमच्या DataFrame मध्ये 60,000 ओळी आणि 400 स्तंभ असतील, तर तुम्ही काय काम करत आहात याची कल्पना कशी कराल? सुदैवाने, [pandas](https://pandas.pydata.org/) काही सोयीस्कर साधने प्रदान करते ज्यामुळे DataFrame बद्दल एकूण माहिती पटकन पाहता येते, तसेच पहिल्या काही आणि शेवटच्या काही ओळी.

या कार्यक्षमता एक्सप्लोर करण्यासाठी, आपण Python scikit-learn लायब्ररी आयात करू आणि एक प्रसिद्ध डेटासेट वापरू: **Iris डेटा सेट**.

```python
import pandas as pd
from sklearn.datasets import load_iris

iris = load_iris()
iris_df = pd.DataFrame(data=iris['data'], columns=iris['feature_names'])
```
|                                        |sepal length (cm)|sepal width (cm)|petal length (cm)|petal width (cm)|
|----------------------------------------|-----------------|----------------|-----------------|----------------|
|0                                       |5.1              |3.5             |1.4              |0.2             |
|1                                       |4.9              |3.0             |1.4              |0.2             |
|2                                       |4.7              |3.2             |1.3              |0.2             |
|3                                       |4.6              |3.1             |1.5              |0.2             |
|4                                       |5.0              |3.6             |1.4              |0.2             |

- **DataFrame.info**: सुरुवातीला, `info()` पद्धत वापरून `DataFrame` मध्ये असलेल्या सामग्रीचा सारांश प्रिंट केला जातो. चला या डेटासेटकडे पाहूया:
```python
iris_df.info()
```
```
RangeIndex: 150 entries, 0 to 149
Data columns (total 4 columns):
 #   Column             Non-Null Count  Dtype  
---  ------             --------------  -----  
 0   sepal length (cm)  150 non-null    float64
 1   sepal width (cm)   150 non-null    float64
 2   petal length (cm)  150 non-null    float64
 3   petal width (cm)   150 non-null    float64
dtypes: float64(4)
memory usage: 4.8 KB
```
यावरून, आपल्याला माहित आहे की *Iris* डेटासेटमध्ये चार स्तंभांमध्ये 150 नोंदी आहेत आणि कोणतेही null नोंदी नाहीत. सर्व डेटा 64-बिट फ्लोटिंग-पॉइंट नंबर म्हणून संग्रहित केला जातो.

- **DataFrame.head()**: पुढे, `DataFrame` च्या वास्तविक सामग्रीची तपासणी करण्यासाठी, आपण `head()` पद्धत वापरतो. चला आपल्या `iris_df` च्या पहिल्या काही ओळी पाहूया:
```python
iris_df.head()
```
```
   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0                5.1               3.5                1.4               0.2
1                4.9               3.0                1.4               0.2
2                4.7               3.2                1.3               0.2
3                4.6               3.1                1.5               0.2
4                5.0               3.6                1.4               0.2
```
- **DataFrame.tail()**: उलट, `DataFrame` च्या शेवटच्या काही ओळी तपासण्यासाठी, आपण `tail()` पद्धत वापरतो:
```python
iris_df.tail()
```
```
     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
145                6.7               3.0                5.2               2.3
146                6.3               2.5                5.0               1.9
147                6.5               3.0                5.2               2.0
148                6.2               3.4                5.4               2.3
149                5.9               3.0                5.1               1.8
```
> **महत्त्वाचे:** फक्त DataFrame मधील माहितीबद्दल मेटाडेटा पाहून किंवा त्यातील पहिल्या आणि शेवटच्या काही मूल्यांकडे पाहून, तुम्ही तुमच्या डेटाच्या आकार, स्वरूप आणि सामग्रीबद्दल त्वरित कल्पना करू शकता.

## हरवलेल्या डेटाशी व्यवहार करणे
> **शिकण्याचे उद्दिष्ट:** या उपविभागाच्या शेवटी, तुम्हाला DataFrames मधून null मूल्ये बदलणे किंवा काढून टाकणे माहित असले पाहिजे.

बहुतेक वेळा तुम्हाला वापरायचे (किंवा वापरणे भाग पडलेले) डेटासेट्समध्ये हरवलेली मूल्ये असतात. हरवलेल्या डेटाशी कसे व्यवहार केले जाते यामध्ये सूक्ष्म तडजोडी असतात ज्या तुमच्या अंतिम विश्लेषणावर आणि वास्तविक जगातील परिणामांवर परिणाम करू शकतात.

Pandas हरवलेल्या मूल्यांशी दोन प्रकारे व्यवहार करते. पहिला तुम्ही मागील विभागांमध्ये पाहिला आहे: `NaN`, किंवा Not a Number. हे प्रत्यक्षात IEEE फ्लोटिंग-पॉइंट स्पेसिफिकेशनचा एक विशेष मूल्य आहे आणि ते फक्त हरवलेल्या फ्लोटिंग-पॉइंट मूल्ये दर्शवण्यासाठी वापरले जाते.

फ्लोट्स व्यतिरिक्त हरवलेल्या मूल्यांसाठी, pandas Python `None` ऑब्जेक्ट वापरतो. जरी तुम्हाला दोन वेगवेगळ्या प्रकारच्या मूल्यांचा सामना करावा लागतो ज्यांचा अर्थ सारखाच आहे असे वाटत असले तरी, या डिझाइन निवडीसाठी ठोस प्रोग्रामिंग कारणे आहेत आणि प्रत्यक्षात, या मार्गाने जाणे बहुसंख्य प्रकरणांसाठी pandas चांगला तडजोड प्रदान करण्यास सक्षम करते. याशिवाय, `None` आणि `NaN` दोन्ही मर्यादा घेऊन येतात ज्याबद्दल तुम्हाला जागरूक असणे आवश्यक आहे, ज्या प्रकारे त्यांचा वापर केला जाऊ शकतो.

`NaN` आणि `None` बद्दल अधिक जाणून घ्या [नोटबुक](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/4-Data-Science-Lifecycle/15-analyzing/notebook.ipynb) मधून!

- **null मूल्ये शोधणे**: `pandas` मध्ये, `isnull()` आणि `notnull()` पद्धती तुमच्या डेटामधील null डेटा शोधण्यासाठी प्राथमिक पद्धती आहेत. दोन्ही तुमच्या डेटावर Boolean मास्क परत करतात. आम्ही `NaN` मूल्यांसाठी `numpy` वापरणार आहोत:
```python
import numpy as np

example1 = pd.Series([0, np.nan, '', None])
example1.isnull()
```
```
0    False
1     True
2    False
3     True
dtype: bool
```
आउटपुटकडे बारकाईने पहा. त्यातील काही तुम्हाला आश्चर्यचकित करते का? जरी `0` एक अंकगणितीय null आहे, तरीही तो एक परिपूर्ण पूर्णांक आहे आणि pandas त्याला तसा मानतो. `''` थोडा अधिक सूक्ष्म आहे. जरी आम्ही सेक्शन 1 मध्ये रिक्त स्ट्रिंग मूल्य दर्शवण्यासाठी त्याचा वापर केला, तरीही तो एक स्ट्रिंग ऑब्जेक्ट आहे आणि pandas च्या दृष्टिकोनातून null चे प्रतिनिधित्व नाही.

आता, चला हे उलटवूया आणि या पद्धती अधिक व्यावहारिक पद्धतीने वापरूया. तुम्ही Boolean मास्क थेट ``Series`` किंवा ``DataFrame`` इंडेक्स म्हणून वापरू शकता, जे हरवलेल्या (किंवा उपस्थित) मूल्यांसोबत काम करताना उपयुक्त ठरू शकते.

> **महत्त्वाचे:** `isnull()` आणि `notnull()` पद्धती `DataFrame`s मध्ये वापरल्यावर समान परिणाम तयार करतात: त्या परिणाम आणि त्या परिणामांचा इंडेक्स दर्शवतात, जे तुम्हाला तुमच्या डेटाशी झगडताना खूप मदत करतील.

- **null मूल्ये काढणे**: हरवलेल्या मूल्यांची ओळख पटवण्याव्यतिरिक्त, pandas `Series` आणि `DataFrame`s मधून null मूल्ये काढण्यासाठी सोयीस्कर साधन प्रदान करते. (विशेषतः मोठ्या डेटासेट्सवर, हरवलेल्या [NA] मूल्यांना इतर प्रकारे हाताळण्याऐवजी तुमच्या विश्लेषणातून काढून टाकणे अधिक शहाणपणाचे असते.) हे कृतीत पाहण्यासाठी, चला `example1` वर परत जाऊया:
```python
example1 = example1.dropna()
example1
```
```
0    0
2     
dtype: object
```
लक्षात घ्या की हे तुमच्या `example3[example3.notnull()]` च्या आउटपुटसारखे दिसले पाहिजे. येथे फरक असा आहे की, मास्क केलेल्या मूल्यांवर फक्त इंडेक्सिंग करण्याऐवजी, `dropna` ने `Series` `example1` मधून हरवलेली मूल्ये काढून टाकली आहेत.

`DataFrame`s मध्ये दोन परिमाणे असल्यामुळे, ते डेटा काढण्यासाठी अधिक पर्याय देतात.

```python
example2 = pd.DataFrame([[1,      np.nan, 7], 
                         [2,      5,      8], 
                         [np.nan, 6,      9]])
example2
```
|      | 0 | 1 | 2 |
|------|---|---|---|
|0     |1.0|NaN|7  |
|1     |2.0|5.0|8  |
|2     |NaN|6.0|9  |

(pandas ने `NaN`s accommodate करण्यासाठी दोन स्तंभ फ्लोट्समध्ये अपकास्ट केले आहेत का?)

तुम्ही `DataFrame` मधून एकच मूल्य काढू शकत नाही, त्यामुळे तुम्हाला संपूर्ण ओळी किंवा स्तंभ काढावे लागतात. तुम्ही काय करत आहात यावर अवलंबून, तुम्हाला एक किंवा दुसरे करायचे असू शकते, आणि त्यामुळे pandas तुम्हाला दोन्ही पर्याय देतो. कारण डेटा सायन्समध्ये, स्तंभ सामान्यतः व्हेरिएबल्सचे प्रतिनिधित्व करतात आणि ओळी निरीक्षणांचे प्रतिनिधित्व करतात, तुम्ही डेटा ओळी काढण्याची अधिक शक्यता असते; `dropna()` साठी डीफॉल्ट सेटिंग म्हणजे null मूल्ये असलेल्या सर्व ओळी काढणे:

```python
example2.dropna()
```
```
	0	1	2
1	2.0	5.0	8
```
आवश्यक असल्यास, तुम्ही स्तंभांमधून NA मूल्ये काढू शकता. `axis=1` वापरा:
```python
example2.dropna(axis='columns')
```
```
	2
0	7
1	8
2	9
```
लक्षात घ्या की हे तुम्हाला ठेवायचा डेटा मोठ्या प्रमाणात काढू शकते, विशेषतः लहान डेटासेट्समध्ये. जर तुम्हाला फक्त काही किंवा सर्व null मूल्ये असलेल्या ओळी किंवा स्तंभ काढायचे असतील तर काय? तुम्ही `dropna` मध्ये `how` आणि `thresh` पॅरामीटर्ससह ती सेटिंग्ज निर्दिष्ट करता.

डीफॉल्टनुसार, `how='any'` (जर तुम्हाला स्वतः तपासायचे असेल किंवा पद्धतीमध्ये इतर कोणते पॅरामीटर्स आहेत ते पाहायचे असेल, तर कोड सेलमध्ये `example4.dropna?` चालवा). तुम्ही `how='all'` निर्दिष्ट करू शकता जेणेकरून फक्त सर्व null मूल्ये असलेल्या ओळी किंवा स्तंभ काढले जातील. हे कृतीत पाहण्यासाठी आपले उदाहरण `DataFrame` विस्तृत करूया.

```python
example2[3] = np.nan
example2
```
|      |0  |1  |2  |3  |
|------|---|---|---|---|
|0     |1.0|NaN|7  |NaN|
|1     |2.0|5.0|8  |NaN|
|2     |NaN|6.0|9  |NaN|

`thresh` पॅरामीटर तुम्हाला अधिक सूक्ष्म नियंत्रण देते: तुम्ही सेट करता की ओळी किंवा स्तंभ ठेवण्यासाठी किती *non-null* मूल्ये असणे आवश्यक आहे:
```python
example2.dropna(axis='rows', thresh=3)
```
```
	0	1	2	3
1	2.0	5.0	8	NaN
```
येथे, पहिली आणि शेवटची ओळ काढून टाकली गेली आहे, कारण त्यामध्ये फक्त दोन non-null मूल्ये आहेत.

- **null मूल्ये भरत आहे**: तुमच्या डेटासेटवर अवलंबून, कधी कधी null मूल्ये काढण्याऐवजी वैध मूल्ये भरून ठेवणे अधिक अर्थपूर्ण असते. तुम्ही `isnull` वापरून हे जागेवर करू शकता, परंतु ते श्रमसाध्य असू शकते, विशेषतः जर तुम्हाला भरायचे मूल्ये खूप असतील. कारण डेटा सायन्समध्ये ही एक सामान्य कार्य आहे, pandas `fillna` प्रदान करते, जे तुमच्या निवडीच्या मूल्याने हरवलेल्या मूल्यांसह `Series` किंवा `DataFrame` ची प्रत परत करते. हे प्रत्यक्षात कसे कार्य करते हे पाहण्यासाठी आणखी एक उदाहरण `Series` तयार करूया.
```python
example3 = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))
example3
```
```
a    1.0
b    NaN
c    2.0
d    NaN
e    3.0
dtype: float64
```
तुम्ही सर्व null नोंदी एका मूल्याने, जसे की `0`, भरू शकता:
```python
example3.fillna(0)
```
```
a    1.0
b    0.0
c    2.0
d    0.0
e    3.0
dtype: float64
```
तुम्ही null मूल्ये **फॉरवर्ड-फिल** करू शकता, म्हणजे शेवटचे वैध मूल्य null भरण्यासाठी वापरू शकता:
```python
example3.fillna(method='ffill')
```
```
a    1.0
b    1.0
c    2.0
d    2.0
e    3.0
dtype: float64
```
तुम्ही null भरण्यासाठी पुढील वैध मूल्य मागे नेऊन **बॅक-फिल** करू शकता:
```python
example3.fillna(method='bfill')
```
```
a    1.0
b    2.0
c    2.0
d    3.0
e    3.0
dtype: float64
```
तुम्ही अंदाज करू शकता, हे `DataFrame`s सोबत समान कार्य करते, परंतु तुम्ही null मूल्ये भरण्यासाठी `axis` देखील निर्दिष्ट करू शकता. पुन्हा वापरलेला `example2` घेत:
```python
example2.fillna(method='ffill', axis=1)
```
```
	0	1	2	3
0	1.0	1.0	7.0	7.0
1	2.0	5.0	8.0	8.0
2	NaN	6.0	9.0	9.0
```
लक्षात घ्या की जेव्हा फॉरवर्ड-फिलसाठी मागील मूल्य उपलब्ध नसते, तेव्हा null मूल्य तसेच राहते.
> **महत्त्वाचे:** तुमच्या डेटासेटमधील गहाळ मूल्यांशी व्यवहार करण्याचे अनेक मार्ग आहेत. तुम्ही वापरलेली विशिष्ट रणनीती (त्यांना काढून टाकणे, त्यांची जागा घेणे, किंवा त्यांची जागा कशी घेणे) त्या डेटाच्या विशिष्ट तपशीलांवर अवलंबून असते. तुम्ही जितके अधिक डेटासेट हाताळाल आणि त्यांच्याशी संवाद साधाल तितके गहाळ मूल्यांशी व्यवहार कसा करायचा याची चांगली समज विकसित होईल.
## डुप्लिकेट डेटा काढून टाकणे

> **शिकण्याचे उद्दिष्ट:** या उपविभागाच्या शेवटी, तुम्हाला DataFrames मधून डुप्लिकेट मूल्ये ओळखणे आणि काढून टाकणे सोपे वाटेल.

हरवलेल्या डेटाच्या व्यतिरिक्त, तुम्हाला वास्तविक-जगातील डेटासेटमध्ये अनेकदा डुप्लिकेट डेटा सापडतो. सुदैवाने, `pandas` डुप्लिकेट नोंदी शोधण्यासाठी आणि काढून टाकण्यासाठी सोपी पद्धत प्रदान करते.

- **डुप्लिकेट ओळखणे: `duplicated`**: `pandas` मधील `duplicated` पद्धतीचा वापर करून तुम्ही डुप्लिकेट मूल्ये सहज ओळखू शकता, जी Boolean मास्क परत करते, ज्यामध्ये `DataFrame` मधील एखादी नोंद आधीच्या नोंदीची डुप्लिकेट आहे का हे दर्शवले जाते. हे कृतीत पाहण्यासाठी आणखी एक उदाहरण `DataFrame` तयार करूया.
```python
example4 = pd.DataFrame({'letters': ['A','B'] * 2 + ['B'],
                         'numbers': [1, 2, 1, 3, 3]})
example4
```
|      |letters|numbers|
|------|-------|-------|
|0     |A      |1      |
|1     |B      |2      |
|2     |A      |1      |
|3     |B      |3      |
|4     |B      |3      |

```python
example4.duplicated()
```
```
0    False
1    False
2     True
3    False
4     True
dtype: bool
```
- **डुप्लिकेट काढून टाकणे: `drop_duplicates`:** `duplicated` मूल्ये `False` असलेल्या डेटाची प्रत परत करते:
```python
example4.drop_duplicates()
```
```
	letters	numbers
0	A	1
1	B	2
3	B	3
```
`duplicated` आणि `drop_duplicates` हे दोन्ही डीफॉल्टने सर्व स्तंभ विचारात घेतात, परंतु तुम्ही तुमच्या `DataFrame` मधील फक्त विशिष्ट स्तंभ तपासण्यासाठी निर्दिष्ट करू शकता:
```python
example4.drop_duplicates(['letters'])
```
```
letters	numbers
0	A	1
1	B	2
```

> **महत्त्वाचा मुद्दा:** डुप्लिकेट डेटा काढून टाकणे हे जवळजवळ प्रत्येक डेटा-सायन्स प्रकल्पाचा एक महत्त्वाचा भाग आहे. डुप्लिकेट डेटा तुमच्या विश्लेषणाचे परिणाम बदलू शकतो आणि तुम्हाला चुकीचे परिणाम देऊ शकतो!


## 🚀 आव्हान

सर्व चर्चिलेले साहित्य [Jupyter Notebook](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/2-Working-With-Data/08-data-preparation/notebook.ipynb) स्वरूपात उपलब्ध आहे. याशिवाय, प्रत्येक विभागानंतर सरावासाठी काही व्यायाम दिले आहेत, त्यांना नक्की करून पहा!

## [व्याख्यानानंतरचा क्विझ](https://ff-quizzes.netlify.app/en/ds/quiz/15)



## पुनरावलोकन आणि स्व-अभ्यास

तुमच्या डेटाचे विश्लेषण आणि मॉडेलिंगसाठी तयारी करण्याचे आणि डेटा स्वच्छ करण्याचे अनेक मार्ग आहेत, आणि हा एक महत्त्वाचा टप्पा आहे जो "हाताळण्याचा" अनुभव आहे. या धड्यात समाविष्ट नसलेल्या तंत्रांचा शोध घेण्यासाठी Kaggle वरील या आव्हानांचा प्रयत्न करा.

- [डेटा स्वच्छता आव्हान: तारखा पार्स करणे](https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/)

- [डेटा स्वच्छता आव्हान: डेटा स्केल आणि सामान्यीकरण](https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data)


## असाइनमेंट

[फॉर्ममधील डेटाचे मूल्यांकन करणे](assignment.md)

---

**अस्वीकरण**:  
हा दस्तऐवज AI भाषांतर सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) वापरून भाषांतरित करण्यात आला आहे. आम्ही अचूकतेसाठी प्रयत्नशील असलो तरी, कृपया लक्षात ठेवा की स्वयंचलित भाषांतरांमध्ये त्रुटी किंवा अचूकतेचा अभाव असू शकतो. मूळ भाषेतील दस्तऐवज हा अधिकृत स्रोत मानावा. महत्त्वाच्या माहितीसाठी व्यावसायिक मानवी भाषांतराची शिफारस केली जाते. या भाषांतराचा वापर करून उद्भवलेल्या कोणत्याही गैरसमज किंवा चुकीच्या अर्थासाठी आम्ही जबाबदार राहणार नाही.