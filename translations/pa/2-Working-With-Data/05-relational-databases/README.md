<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "9399d7b4767e75068f95ce5c660b285c",
  "translation_date": "2025-09-06T08:06:31+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "pa"
}
-->
# ਡਾਟਾ ਨਾਲ ਕੰਮ ਕਰਨਾ: ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ

|![ [(@sketchthedocs)] ਦੁਆਰਾ ਬਣਾਈ ਗਈ ਸਕੈਚਨੋਟ](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| ਡਾਟਾ ਨਾਲ ਕੰਮ ਕਰਨਾ: ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ - _[@nitya](https://twitter.com/nitya) ਦੁਆਰਾ ਬਣਾਈ ਗਈ ਸਕੈਚਨੋਟ_ |

ਸਭ ਸੰਭਾਵਨਾ ਹੈ ਕਿ ਤੁਸੀਂ ਪਹਿਲਾਂ ਜਾਣਕਾਰੀ ਸਟੋਰ ਕਰਨ ਲਈ ਸਪ੍ਰੈਡਸ਼ੀਟ ਦੀ ਵਰਤੋਂ ਕੀਤੀ ਹੋਵੇਗੀ। ਤੁਹਾਡੇ ਕੋਲ ਕਤਾਰਾਂ ਅਤੇ ਕਾਲਮਾਂ ਦਾ ਇੱਕ ਸੈੱਟ ਸੀ, ਜਿੱਥੇ ਕਤਾਰਾਂ ਵਿੱਚ ਜਾਣਕਾਰੀ (ਜਾਂ ਡਾਟਾ) ਸੀ, ਅਤੇ ਕਾਲਮਾਂ ਨੇ ਜਾਣਕਾਰੀ ਦਾ ਵਰਣਨ ਕੀਤਾ (ਕਈ ਵਾਰ ਇਸਨੂੰ ਮੈਟਾਡਾਟਾ ਕਿਹਾ ਜਾਂਦਾ ਹੈ)। ਇੱਕ ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਕਤਾਰਾਂ ਅਤੇ ਕਾਲਮਾਂ ਦੇ ਇਸ ਮੁੱਖ ਸਿਧਾਂਤ 'ਤੇ ਬਣਾਇਆ ਜਾਂਦਾ ਹੈ, ਜੋ ਤੁਹਾਨੂੰ ਜਾਣਕਾਰੀ ਨੂੰ ਕਈ ਟੇਬਲਾਂ ਵਿੱਚ ਫੈਲਾਉਣ ਦੀ ਆਗਿਆ ਦਿੰਦਾ ਹੈ। ਇਹ ਤੁਹਾਨੂੰ ਜਟਿਲ ਡਾਟਾ ਨਾਲ ਕੰਮ ਕਰਨ, ਡੁਪਲੀਕੇਸ਼ਨ ਤੋਂ ਬਚਣ ਅਤੇ ਡਾਟਾ ਦੀ ਜਾਂਚ ਕਰਨ ਦੇ ਤਰੀਕੇ ਵਿੱਚ ਲਚਕਦਾਰਤਾ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ। ਆਓ ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਦੇ ਸਿਧਾਂਤਾਂ ਦੀ ਜਾਂਚ ਕਰੀਏ।

## [ਪ੍ਰੀ-ਲੈਕਚਰ ਕਵਿਜ਼](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## ਇਹ ਸਾਰਾ ਕੁਝ ਟੇਬਲਾਂ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ

ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਦਾ ਮੁੱਖ ਹਿੱਸਾ ਟੇਬਲਾਂ ਹੁੰਦੀਆਂ ਹਨ। ਸਪ੍ਰੈਡਸ਼ੀਟ ਦੀ ਤਰ੍ਹਾਂ, ਇੱਕ ਟੇਬਲ ਕਤਾਰਾਂ ਅਤੇ ਕਾਲਮਾਂ ਦਾ ਇੱਕ ਸੰਗ੍ਰਹਿ ਹੁੰਦਾ ਹੈ। ਕਤਾਰ ਵਿੱਚ ਉਹ ਡਾਟਾ ਜਾਂ ਜਾਣਕਾਰੀ ਹੁੰਦੀ ਹੈ ਜਿਸ ਨਾਲ ਅਸੀਂ ਕੰਮ ਕਰਨਾ ਚਾਹੁੰਦੇ ਹਾਂ, ਜਿਵੇਂ ਕਿ ਸ਼ਹਿਰ ਦਾ ਨਾਮ ਜਾਂ ਵਰਖਾ ਦੀ ਮਾਤਰਾ। ਕਾਲਮ ਉਸ ਡਾਟਾ ਦਾ ਵਰਣਨ ਕਰਦੇ ਹਨ ਜੋ ਉਹ ਸਟੋਰ ਕਰਦੇ ਹਨ।

ਆਓ ਸ਼ਹਿਰਾਂ ਬਾਰੇ ਜਾਣਕਾਰੀ ਸਟੋਰ ਕਰਨ ਲਈ ਇੱਕ ਟੇਬਲ ਸ਼ੁਰੂ ਕਰਕੇ ਆਪਣੀ ਜਾਂਚ ਸ਼ੁਰੂ ਕਰੀਏ। ਅਸੀਂ ਸ਼ਾਇਦ ਉਨ੍ਹਾਂ ਦੇ ਨਾਮ ਅਤੇ ਦੇਸ਼ ਨਾਲ ਸ਼ੁਰੂ ਕਰ ਸਕਦੇ ਹਾਂ। ਤੁਸੀਂ ਇਸਨੂੰ ਹੇਠਾਂ ਦਿੱਤੇ ਟੇਬਲ ਵਿੱਚ ਸਟੋਰ ਕਰ ਸਕਦੇ ਹੋ:

| ਸ਼ਹਿਰ     | ਦੇਸ਼           |
| -------- | ------------- |
| ਟੋਕਿਓ    | ਜਪਾਨ         |
| ਐਟਲਾਂਟਾ  | ਸੰਯੁਕਤ ਰਾਜ   |
| ਆਕਲੈਂਡ   | ਨਿਊਜ਼ੀਲੈਂਡ   |

ਨੋਟ ਕਰੋ ਕਿ **ਸ਼ਹਿਰ**, **ਦੇਸ਼**, ਅਤੇ **ਆਬਾਦੀ** ਦੇ ਕਾਲਮ ਨਾਮ ਸਟੋਰ ਕੀਤੇ ਜਾ ਰਹੇ ਡਾਟਾ ਦਾ ਵਰਣਨ ਕਰਦੇ ਹਨ, ਅਤੇ ਹਰ ਕਤਾਰ ਵਿੱਚ ਇੱਕ ਸ਼ਹਿਰ ਬਾਰੇ ਜਾਣਕਾਰੀ ਹੈ।

## ਇੱਕ ਟੇਬਲ ਪਹੁੰਚ ਦੇ ਘਾਟ

ਸਭ ਸੰਭਾਵਨਾ ਹੈ ਕਿ ਉਪਰੋਕਤ ਟੇਬਲ ਤੁਹਾਨੂੰ ਕਾਫ਼ੀ ਜਾਣੀ-ਪਛਾਣੀ ਲੱਗਦੀ ਹੈ। ਆਓ ਆਪਣੀ ਡਾਟਾਬੇਸ ਵਿੱਚ ਕੁਝ ਵਾਧੂ ਡਾਟਾ ਸ਼ਾਮਲ ਕਰੀਏ - ਸਾਲਾਨਾ ਵਰਖਾ (ਮਿਲੀਮੀਟਰ ਵਿੱਚ)। ਅਸੀਂ 2018, 2019 ਅਤੇ 2020 ਦੇ ਸਾਲਾਂ 'ਤੇ ਧਿਆਨ ਦੇਵਾਂਗੇ। ਜੇ ਅਸੀਂ ਇਹ ਟੋਕਿਓ ਲਈ ਸ਼ਾਮਲ ਕਰਨਾ ਹੋਵੇ, ਤਾਂ ਇਹ ਕੁਝ ਇਸ ਤਰ੍ਹਾਂ ਲੱਗ ਸਕਦਾ ਹੈ:

| ਸ਼ਹਿਰ  | ਦੇਸ਼   | ਸਾਲ | ਮਾਤਰਾ |
| ----- | ------- | ---- | ------ |
| ਟੋਕਿਓ | ਜਪਾਨ   | 2020 | 1690   |
| ਟੋਕਿਓ | ਜਪਾਨ   | 2019 | 1874   |
| ਟੋਕਿਓ | ਜਪਾਨ   | 2018 | 1445   |

ਤੁਸੀਂ ਸਾਡੇ ਟੇਬਲ ਬਾਰੇ ਕੀ ਨੋਟ ਕਰਦੇ ਹੋ? ਤੁਸੀਂ ਸ਼ਾਇਦ ਨੋਟ ਕਰਦੇ ਹੋ ਕਿ ਅਸੀਂ ਸ਼ਹਿਰ ਦਾ ਨਾਮ ਅਤੇ ਦੇਸ਼ ਨੂੰ ਵਾਰ-ਵਾਰ ਦੁਹਰਾ ਰਹੇ ਹਾਂ। ਇਹ ਕਾਫ਼ੀ ਸਟੋਰੇਜ ਲੈ ਸਕਦਾ ਹੈ, ਅਤੇ ਵੱਡੇ ਪੱਧਰ 'ਤੇ ਇਹ ਬੇਲੋੜਾ ਹੈ। ਆਖਰਕਾਰ, ਟੋਕਿਓ ਸਿਰਫ ਇੱਕ ਨਾਮ ਹੈ ਜਿਸ ਵਿੱਚ ਅਸੀਂ ਦਿਲਚਸਪੀ ਰੱਖਦੇ ਹਾਂ।

ਚਲੋ, ਕੁਝ ਹੋਰ ਕੋਸ਼ਿਸ਼ ਕਰੀਏ। ਆਓ ਹਰ ਸਾਲ ਲਈ ਨਵੇਂ ਕਾਲਮ ਸ਼ਾਮਲ ਕਰੀਏ:

| ਸ਼ਹਿਰ     | ਦੇਸ਼           | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| ਟੋਕਿਓ    | ਜਪਾਨ         | 1445 | 1874 | 1690 |
| ਐਟਲਾਂਟਾ  | ਸੰਯੁਕਤ ਰਾਜ   | 1779 | 1111 | 1683 |
| ਆਕਲੈਂਡ   | ਨਿਊਜ਼ੀਲੈਂਡ   | 1386 | 942  | 1176 |

ਜਦੋਂ ਕਿ ਇਹ ਕਤਾਰਾਂ ਦੀ ਦੁਹਰਾਈ ਤੋਂ ਬਚਦਾ ਹੈ, ਇਹ ਕੁਝ ਹੋਰ ਚੁਣੌਤੀਆਂ ਜੋੜਦਾ ਹੈ। ਸਾਨੂੰ ਹਰ ਵਾਰ ਇੱਕ ਨਵੇਂ ਸਾਲ ਦੇ ਆਉਣ 'ਤੇ ਆਪਣੇ ਟੇਬਲ ਦੀ ਬਣਤਰ ਨੂੰ ਸੋਧਣ ਦੀ ਲੋੜ ਹੋਵੇਗੀ। ਇਸ ਤੋਂ ਇਲਾਵਾ, ਜਦੋਂ ਸਾਡਾ ਡਾਟਾ ਵਧਦਾ ਹੈ, ਸਾਲਾਂ ਨੂੰ ਕਾਲਮਾਂ ਵਜੋਂ ਰੱਖਣ ਨਾਲ ਮੁੱਲਾਂ ਨੂੰ ਪ੍ਰਾਪਤ ਕਰਨ ਅਤੇ ਗਣਨਾ ਕਰਨ ਵਿੱਚ ਮੁਸ਼ਕਲ ਹੋਵੇਗੀ।

ਇਸ ਲਈ ਸਾਨੂੰ ਕਈ ਟੇਬਲਾਂ ਅਤੇ ਰਿਸ਼ਤਿਆਂ ਦੀ ਲੋੜ ਹੈ। ਆਪਣੇ ਡਾਟਾ ਨੂੰ ਵੱਖ-ਵੱਖ ਕਰਕੇ ਅਸੀਂ ਦੁਹਰਾਈ ਤੋਂ ਬਚ ਸਕਦੇ ਹਾਂ ਅਤੇ ਆਪਣੇ ਡਾਟਾ ਨਾਲ ਕੰਮ ਕਰਨ ਦੇ ਤਰੀਕੇ ਵਿੱਚ ਵਧੇਰੇ ਲਚਕਦਾਰਤਾ ਪ੍ਰਾਪਤ ਕਰ ਸਕਦੇ ਹਾਂ।

## ਰਿਸ਼ਤਿਆਂ ਦੇ ਸਿਧਾਂਤ

ਆਓ ਆਪਣੇ ਡਾਟਾ ਵੱਲ ਵਾਪਸ ਆਈਏ ਅਤੇ ਇਹ ਨਿਰਧਾਰਤ ਕਰੀਏ ਕਿ ਅਸੀਂ ਇਸਨੂੰ ਕਿਵੇਂ ਵੱਖ ਕਰਨਾ ਚਾਹੁੰਦੇ ਹਾਂ। ਅਸੀਂ ਜਾਣਦੇ ਹਾਂ ਕਿ ਅਸੀਂ ਆਪਣੇ ਸ਼ਹਿਰਾਂ ਲਈ ਨਾਮ ਅਤੇ ਦੇਸ਼ ਸਟੋਰ ਕਰਨਾ ਚਾਹੁੰਦੇ ਹਾਂ, ਇਸ ਲਈ ਇਹ ਸ਼ਾਇਦ ਇੱਕ ਟੇਬਲ ਵਿੱਚ ਸਭ ਤੋਂ ਵਧੀਆ ਕੰਮ ਕਰੇਗਾ।

| ਸ਼ਹਿਰ     | ਦੇਸ਼           |
| -------- | ------------- |
| ਟੋਕਿਓ    | ਜਪਾਨ         |
| ਐਟਲਾਂਟਾ  | ਸੰਯੁਕਤ ਰਾਜ   |
| ਆਕਲੈਂਡ   | ਨਿਊਜ਼ੀਲੈਂਡ   |

ਪਰ ਅਗਲੀ ਟੇਬਲ ਬਣਾਉਣ ਤੋਂ ਪਹਿਲਾਂ, ਸਾਨੂੰ ਇਹ ਪਤਾ ਲਗਾਉਣਾ ਹੋਵੇਗਾ ਕਿ ਹਰ ਸ਼ਹਿਰ ਨੂੰ ਕਿਵੇਂ ਰਿਫਰੈਂਸ ਕਰਨਾ ਹੈ। ਸਾਨੂੰ ਕਿਸੇ ਤਰ੍ਹਾਂ ਦਾ ਇੱਕ ਆਈਡੈਂਟੀਫਾਇਰ, ID ਜਾਂ (ਤਕਨੀਕੀ ਡਾਟਾਬੇਸ ਸ਼ਬਦਾਂ ਵਿੱਚ) ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਕੀ ਦੀ ਲੋੜ ਹੈ। ਪ੍ਰਾਇਮਰੀ ਕੀ ਇੱਕ ਮੁੱਲ ਹੈ ਜੋ ਇੱਕ ਟੇਬਲ ਵਿੱਚ ਇੱਕ ਵਿਸ਼ੇਸ਼ ਕਤਾਰ ਦੀ ਪਛਾਣ ਕਰਨ ਲਈ ਵਰਤਿਆ ਜਾਂਦਾ ਹੈ। ਜਦੋਂ ਕਿ ਇਹ ਖੁਦ ਇੱਕ ਮੁੱਲ 'ਤੇ ਆਧਾਰਿਤ ਹੋ ਸਕਦਾ ਹੈ (ਉਦਾਹਰਣ ਲਈ, ਅਸੀਂ ਸ਼ਹਿਰ ਦੇ ਨਾਮ ਦੀ ਵਰਤੋਂ ਕਰ ਸਕਦੇ ਹਾਂ), ਇਹ ਲਗਭਗ ਹਮੇਸ਼ਾ ਇੱਕ ਨੰਬਰ ਜਾਂ ਹੋਰ ਆਈਡੈਂਟੀਫਾਇਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ। ਅਸੀਂ ਨਹੀਂ ਚਾਹੁੰਦੇ ਕਿ ID ਕਦੇ ਵੀ ਬਦਲੇ ਕਿਉਂਕਿ ਇਹ ਰਿਸ਼ਤੇ ਨੂੰ ਤੋੜ ਦੇਵੇਗਾ। ਤੁਸੀਂ ਜ਼ਿਆਦਾਤਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਪਾਓਗੇ ਕਿ ਪ੍ਰਾਇਮਰੀ ਕੀ ਜਾਂ ID ਇੱਕ ਆਟੋ-ਜਨਰੇਟ ਕੀਤੇ ਨੰਬਰ ਹੋਵੇਗਾ।

> ✅ ਪ੍ਰਾਇਮਰੀ ਕੀ ਨੂੰ ਅਕਸਰ PK ਵਜੋਂ ਸੰਖੇਪ ਕੀਤਾ ਜਾਂਦਾ ਹੈ

### ਸ਼ਹਿਰਾਂ

| city_id | ਸ਼ਹਿਰ     | ਦੇਸ਼           |
| ------- | -------- | ------------- |
| 1       | ਟੋਕਿਓ    | ਜਪਾਨ         |
| 2       | ਐਟਲਾਂਟਾ  | ਸੰਯੁਕਤ ਰਾਜ   |
| 3       | ਆਕਲੈਂਡ   | ਨਿਊਜ਼ੀਲੈਂਡ   |

> ✅ ਤੁਸੀਂ ਨੋਟ ਕਰੋਗੇ ਕਿ ਅਸੀਂ ਇਸ ਪਾਠ ਦੌਰਾਨ "ID" ਅਤੇ "ਪ੍ਰਾਇਮਰੀ ਕੀ" ਸ਼ਬਦਾਂ ਨੂੰ ਅਦਲ-ਬਦਲ ਕਰਕੇ ਵਰਤਦੇ ਹਾਂ। ਇੱਥੇ ਦਿੱਤੇ ਸਿਧਾਂਤ DataFrames 'ਤੇ ਵੀ ਲਾਗੂ ਹੁੰਦੇ ਹਨ, ਜਿਸਨੂੰ ਤੁਸੀਂ ਬਾਅਦ ਵਿੱਚ ਖੋਜੋਗੇ। DataFrames "ਪ੍ਰਾਇਮਰੀ ਕੀ" ਦੀ ਸ਼ਬਦਾਵਲੀ ਦੀ ਵਰਤੋਂ ਨਹੀਂ ਕਰਦੇ, ਹਾਲਾਂਕਿ ਤੁਸੀਂ ਨੋਟ ਕਰੋਗੇ ਕਿ ਉਹ ਲਗਭਗ ਇੱਕੋ ਤਰੀਕੇ ਨਾਲ ਕੰਮ ਕਰਦੇ ਹਨ।

ਸਾਡੇ ਸ਼ਹਿਰਾਂ ਦੇ ਟੇਬਲ ਬਣਾਉਣ ਦੇ ਨਾਲ, ਆਓ ਵਰਖਾ ਸਟੋਰ ਕਰੀਏ। ਪੂਰੀ ਜਾਣਕਾਰੀ ਦੁਹਰਾਉਣ ਦੀ ਬਜਾਏ, ਅਸੀਂ ID ਦੀ ਵਰਤੋਂ ਕਰ ਸਕਦੇ ਹਾਂ। ਸਾਨੂੰ ਇਹ ਵੀ ਯਕੀਨੀ ਬਣਾਉਣਾ ਚਾਹੀਦਾ ਹੈ ਕਿ ਨਵੀਂ ਬਣਾਈ ਗਈ ਟੇਬਲ ਵਿੱਚ ਇੱਕ *ID* ਕਾਲਮ ਹੈ, ਕਿਉਂਕਿ ਸਾਰੀਆਂ ਟੇਬਲਾਂ ਵਿੱਚ ਇੱਕ ID ਜਾਂ ਪ੍ਰਾਇਮਰੀ ਕੀ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।

### ਵਰਖਾ

| rainfall_id | city_id | ਸਾਲ | ਮਾਤਰਾ |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

ਨਵੀਂ ਬਣਾਈ ਗਈ **rainfall** ਟੇਬਲ ਦੇ ਅੰਦਰ **city_id** ਕਾਲਮ ਨੂੰ ਨੋਟ ਕਰੋ। ਇਸ ਕਾਲਮ ਵਿੱਚ ਉਹ ਮੁੱਲ ਹਨ ਜੋ **cities** ਟੇਬਲ ਵਿੱਚ ID ਨੂੰ ਰਿਫਰੈਂਸ ਕਰਦੇ ਹਨ। ਤਕਨੀਕੀ ਰਿਲੇਸ਼ਨਲ ਡਾਟਾ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਇਸਨੂੰ **foreign key** ਕਿਹਾ ਜਾਂਦਾ ਹੈ; ਇਹ ਦੂਜੇ ਟੇਬਲ ਤੋਂ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਕੀ ਹੈ। ਤੁਸੀਂ ਇਸਨੂੰ ਸਿਰਫ ਇੱਕ ਰਿਫਰੈਂਸ ਜਾਂ ਪੌਇੰਟਰ ਵਜੋਂ ਸੋਚ ਸਕਦੇ ਹੋ। **city_id** 1 ਟੋਕਿਓ ਨੂੰ ਰਿਫਰੈਂਸ ਕਰਦਾ ਹੈ।

> [!NOTE] ਫਾਰਨ ਕੀ ਨੂੰ ਅਕਸਰ FK ਵਜੋਂ ਸੰਖੇਪ ਕੀਤਾ ਜਾਂਦਾ ਹੈ

## ਡਾਟਾ ਪ੍ਰਾਪਤ ਕਰਨਾ

ਸਾਡੇ ਡਾਟਾ ਨੂੰ ਦੋ ਟੇਬਲਾਂ ਵਿੱਚ ਵੱਖ ਕਰਨ ਦੇ ਨਾਲ, ਤੁਸੀਂ ਸ਼ਾਇਦ ਸੋਚ ਰਹੇ ਹੋ ਕਿ ਅਸੀਂ ਇਸਨੂੰ ਕਿਵੇਂ ਪ੍ਰਾਪਤ ਕਰਦੇ ਹਾਂ। ਜੇ ਅਸੀਂ MySQL, SQL Server ਜਾਂ Oracle ਵਰਗੇ ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਦੀ ਵਰਤੋਂ ਕਰ ਰਹੇ ਹਾਂ, ਤਾਂ ਅਸੀਂ ਇੱਕ ਭਾਸ਼ਾ ਦੀ ਵਰਤੋਂ ਕਰ ਸਕਦੇ ਹਾਂ ਜਿਸਨੂੰ Structured Query Language ਜਾਂ SQL ਕਿਹਾ ਜਾਂਦਾ ਹੈ। SQL (ਕਈ ਵਾਰ sequel ਉਚਾਰਨ ਕੀਤਾ ਜਾਂਦਾ ਹੈ) ਇੱਕ ਮਿਆਰੀ ਭਾਸ਼ਾ ਹੈ ਜੋ ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਵਿੱਚ ਡਾਟਾ ਪ੍ਰਾਪਤ ਕਰਨ ਅਤੇ ਸੋਧਣ ਲਈ ਵਰਤੀ ਜਾਂਦੀ ਹੈ।

ਡਾਟਾ ਪ੍ਰਾਪਤ ਕਰਨ ਲਈ ਤੁਸੀਂ ਕਮਾਂਡ `SELECT` ਦੀ ਵਰਤੋਂ ਕਰਦੇ ਹੋ। ਇਸਦਾ ਮੁੱਖ ਹਿੱਸਾ ਇਹ ਹੈ ਕਿ ਤੁਸੀਂ **select** ਕਰਦੇ ਹੋ ਉਹ ਕਾਲਮ ਜੋ ਤੁਸੀਂ ਦੇਖਣਾ ਚਾਹੁੰਦੇ ਹੋ **from** ਉਸ ਟੇਬਲ ਤੋਂ ਜਿਸ ਵਿੱਚ ਉਹ ਹਨ। ਜੇ ਤੁਸੀਂ ਸਿਰਫ ਸ਼ਹਿਰਾਂ ਦੇ ਨਾਮ ਦਿਖਾਉਣਾ ਚਾਹੁੰਦੇ ਹੋ, ਤਾਂ ਤੁਸੀਂ ਹੇਠਾਂ ਦਿੱਤੇ ਕਮਾਂਡ ਦੀ ਵਰਤੋਂ ਕਰ ਸਕਦੇ ਹੋ:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` ਜਿੱਥੇ ਤੁਸੀਂ ਕਾਲਮਾਂ ਦੀ ਸੂਚੀ ਦਿੰਦੇ ਹੋ, ਅਤੇ `FROM` ਜਿੱਥੇ ਤੁਸੀਂ ਟੇਬਲਾਂ ਦੀ ਸੂਚੀ ਦਿੰਦੇ ਹੋ।

> [NOTE] SQL syntax case-insensitive ਹੈ, ਜਿਸਦਾ ਮਤਲਬ ਹੈ ਕਿ `select` ਅਤੇ `SELECT` ਇੱਕੋ ਹੀ ਹਨ। ਹਾਲਾਂਕਿ, ਤੁਸੀਂ ਜਿਸ ਡਾਟਾਬੇਸ ਦੀ ਵਰਤੋਂ ਕਰ ਰਹੇ ਹੋ ਉਸ ਦੇ ਆਧਾਰ 'ਤੇ ਕਾਲਮ ਅਤੇ ਟੇਬਲ case-sensitive ਹੋ ਸਕਦੇ ਹਨ। ਇਸਦੇ ਨਤੀਜੇ ਵਜੋਂ, ਇਹ ਇੱਕ ਵਧੀਆ ਅਭਿਆਸ ਹੈ ਕਿ ਹਮੇਸ਼ਾ ਪ੍ਰੋਗਰਾਮਿੰਗ ਵਿੱਚ ਹਰ ਚੀਜ਼ ਨੂੰ case-sensitive ਮੰਨੋ। ਜਦੋਂ SQL queries ਲਿਖਦੇ ਹੋ, ਆਮ ਰਵਾਜ਼ ਇਹ ਹੈ ਕਿ keywords ਨੂੰ ਸਾਰੇ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਲਿਖੋ।

ਉਪਰੋਕਤ ਕਵੈਰੀ ਸਾਰੇ ਸ਼ਹਿਰਾਂ ਨੂੰ ਦਿਖਾਏਗੀ। ਆਓ ਕਲਪਨਾ ਕਰੀਏ ਕਿ ਅਸੀਂ ਸਿਰਫ ਨਿਊਜ਼ੀਲੈਂਡ ਵਿੱਚ ਸ਼ਹਿਰਾਂ ਨੂੰ ਦਿਖਾਉਣਾ ਚਾਹੁੰਦੇ ਹਾਂ। ਸਾਨੂੰ ਕਿਸੇ ਤਰ੍ਹਾਂ ਦੇ ਫਿਲਟਰ ਦੀ ਲੋੜ ਹੈ। SQL keyword ਇਸ ਲਈ `WHERE` ਹੈ, ਜਾਂ "ਜਿੱਥੇ ਕੁਝ ਸੱਚ ਹੈ"।

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## ਡਾਟਾ ਨੂੰ ਜੋੜਨਾ

ਅਜੇ ਤੱਕ ਅਸੀਂ ਇੱਕ ਟੇਬਲ ਤੋਂ ਡਾਟਾ ਪ੍ਰਾਪਤ ਕੀਤਾ ਹੈ। ਹੁਣ ਅਸੀਂ **cities** ਅਤੇ **rainfall** ਦੋਨੋਂ ਤੋਂ ਡਾਟਾ ਨੂੰ ਇਕੱਠਾ ਕਰਨਾ ਚਾਹੁੰਦੇ ਹਾਂ। ਇਹ ਦੋਨੋਂ ਨੂੰ *join* ਕਰਕੇ ਕੀਤਾ ਜਾਂਦਾ ਹੈ। ਤੁਸੀਂ ਅਸਲ ਵਿੱਚ ਦੋ ਟੇਬਲਾਂ ਦੇ ਵਿਚਕਾਰ ਇੱਕ seam ਬਣਾਉਂਦੇ ਹੋ, ਅਤੇ ਦੋਨੋਂ ਟੇਬਲਾਂ ਦੇ ਕਾਲਮਾਂ ਦੇ ਮੁੱਲਾਂ ਨੂੰ ਮਿਲਾਉਂਦੇ ਹੋ।

ਸਾਡੇ ਉਦਾਹਰਣ ਵਿੱਚ, ਅਸੀਂ **rainfall** ਵਿੱਚ **city_id** ਕਾਲਮ ਨੂੰ **cities** ਵਿੱਚ **city_id** ਕਾਲਮ ਨਾਲ ਮਿਲਾਉਣ ਜਾ ਰਹੇ ਹਾਂ। ਇਹ ਵਰਖਾ ਦੀ ਮਾਤਰਾ ਨੂੰ ਇਸਦੇ ਸਬੰਧਤ ਸ਼ਹਿਰ ਨਾਲ ਮਿਲਾਏਗਾ। ਜਿਸ join ਦੀ ਅਸੀਂ ਵਰਤੋਂ ਕਰਨ ਜਾ ਰਹੇ ਹਾਂ, ਉਸਨੂੰ *inner* join ਕਿਹਾ ਜਾਂਦਾ ਹੈ, ਜਿਸਦਾ ਮਤਲਬ ਹੈ ਕਿ ਜੇਕਰ ਕੋਈ ਕਤਾਰਾਂ ਦੂਜੇ ਟੇਬਲ ਤੋਂ ਕਿਸੇ ਵੀ ਚੀਜ਼ ਨਾਲ ਮੇਲ ਨਹੀਂ ਖਾਂਦੀਆਂ, ਤਾਂ ਉਹ ਦਿਖਾਈ ਨਹੀਂ ਜਾਵੇਗੀ। ਸਾਡੇ ਮਾਮਲੇ ਵਿੱਚ ਹਰ ਸ਼ਹਿਰ ਦੀ ਵਰਖਾ ਹੈ, ਇਸ ਲਈ ਸਭ ਕੁਝ ਦਿਖਾਈ ਦੇਵੇਗਾ।

ਆਓ 2019 ਦੀ ਵਰਖਾ ਸਾਰੇ ਸ਼ਹਿਰਾਂ ਲਈ ਪ੍ਰਾਪਤ ਕਰੀਏ।

ਅਸੀਂ ਇਹ ਕਦਮਾਂ ਵਿੱਚ ਕਰਨ ਜਾ ਰਹੇ ਹਾਂ। ਪਹਿਲਾ ਕਦਮ ਹੈ ਕਾਲਮਾਂ ਨੂੰ seam ਲਈ ਦਰਸਾਉਣਾ - **city_id** ਜਿਵੇਂ ਕਿ ਪਹਿਲਾਂ ਹਾਈਲਾਈਟ ਕੀਤਾ ਗਿਆ ਹੈ।

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

ਅਸੀਂ ਦੋ ਕਾਲਮਾਂ ਨੂੰ ਹਾਈਲਾਈਟ ਕੀਤਾ ਹੈ ਜੋ ਅਸੀਂ ਚਾਹੁੰਦੇ ਹਾਂ, ਅਤੇ ਇਹ ਤੱਥ ਕਿ ਅਸੀਂ **city_id** ਦੁਆਰਾ ਟੇਬਲਾਂ ਨੂੰ ਇਕੱਠਾ ਕਰਨਾ ਚਾਹੁੰਦੇ ਹਾਂ। ਹੁਣ ਅਸੀਂ ਸਿਰਫ 2019 ਸਾਲ ਨੂੰ ਫਿਲਟਰ ਕਰਨ ਲਈ `WHERE` ਸਟੇਟਮ ਸ਼ਾਮਲ ਕਰ ਸਕਦੇ ਹਾਂ।

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## ਸਾਰ

ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਕਈ ਟੇਬਲਾਂ ਵਿੱਚ ਜਾਣਕਾਰੀ ਨੂੰ ਵੱਖ ਕਰਨ 'ਤੇ ਕੇਂਦਰਿਤ ਹੁੰਦੇ ਹਨ, ਜਿਸਨੂੰ ਫਿਰ ਡਿਸਪਲੇਅ ਅਤੇ ਵਿਸ਼ਲੇਸ਼ਣ ਲਈ ਵਾਪਸ ਇਕੱਠਾ ਕੀਤਾ ਜਾਂਦਾ ਹੈ। ਇਹ ਗਣਨਾਵਾਂ ਕਰਨ ਅਤੇ ਹੋਰ ਤਰੀਕੇ ਨਾਲ ਡਾਟਾ ਨੂੰ ਮੋੜਨ ਲਈ ਇੱਕ ਉੱਚ ਪੱਧਰ ਦੀ ਲਚਕਦਾਰਤਾ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ। ਤੁਸੀਂ ਇੱਕ ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਦੇ ਮੁੱਖ ਸਿਧਾਂਤਾਂ ਨੂੰ ਦੇਖਿਆ ਹੈ, ਅਤੇ ਦੋ ਟੇਬਲਾਂ ਦੇ ਵਿਚਕਾਰ ਇੱਕ join ਕਰਨ ਦਾ ਤਰੀਕਾ ਸਿੱਖਿਆ ਹੈ।

## 🚀 ਚੁਣੌਤੀ

ਇੰਟਰਨੈਟ 'ਤੇ ਕਈ ਰਿਲੇਸ਼ਨਲ ਡਾਟਾਬੇਸ ਉਪਲਬਧ ਹਨ। ਤੁਸੀਂ ਉਪਰੋਕਤ ਸਿੱਖੀਆਂ ਗਈਆਂ ਹੁਨਰਾਂ ਦੀ ਵਰਤੋਂ

---

**ਅਸਵੀਕਰਤੀ**:  
ਇਹ ਦਸਤਾਵੇਜ਼ AI ਅਨੁਵਾਦ ਸੇਵਾ [Co-op Translator](https://github.com/Azure/co-op-translator) ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅਨੁਵਾਦ ਕੀਤਾ ਗਿਆ ਹੈ। ਹਾਲਾਂਕਿ ਅਸੀਂ ਸਹੀਅਤ ਲਈ ਯਤਨਸ਼ੀਲ ਹਾਂ, ਕਿਰਪਾ ਕਰਕੇ ਧਿਆਨ ਦਿਓ ਕਿ ਸਵੈਚਾਲਿਤ ਅਨੁਵਾਦਾਂ ਵਿੱਚ ਗਲਤੀਆਂ ਜਾਂ ਅਸੁੱਤੀਆਂ ਹੋ ਸਕਦੀਆਂ ਹਨ। ਮੂਲ ਦਸਤਾਵੇਜ਼ ਨੂੰ ਇਸਦੀ ਮੂਲ ਭਾਸ਼ਾ ਵਿੱਚ ਅਧਿਕਾਰਤ ਸਰੋਤ ਮੰਨਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ। ਮਹੱਤਵਪੂਰਨ ਜਾਣਕਾਰੀ ਲਈ, ਪੇਸ਼ੇਵਰ ਮਨੁੱਖੀ ਅਨੁਵਾਦ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਇਸ ਅਨੁਵਾਦ ਦੀ ਵਰਤੋਂ ਤੋਂ ਪੈਦਾ ਹੋਣ ਵਾਲੇ ਕਿਸੇ ਵੀ ਗਲਤਫਹਿਮੀ ਜਾਂ ਗਲਤ ਵਿਆਖਿਆ ਲਈ ਅਸੀਂ ਜ਼ਿੰਮੇਵਾਰ ਨਹੀਂ ਹਾਂ।