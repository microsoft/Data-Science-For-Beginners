<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "870a0086adbc313a8eea5489bdcb2522",
  "translation_date": "2025-08-24T12:01:52+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "ko"
}
-->
# 데이터 작업: 관계형 데이터베이스

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| 데이터 작업: 관계형 데이터베이스 - _스케치노트 by [@nitya](https://twitter.com/nitya)_ |

과거에 정보를 저장하기 위해 스프레드시트를 사용한 적이 있을 가능성이 높습니다. 스프레드시트에는 행과 열이 있으며, 행은 정보(또는 데이터)를 포함하고 열은 정보를 설명합니다(때로는 메타데이터라고도 함). 관계형 데이터베이스는 테이블의 행과 열이라는 핵심 원칙을 기반으로 구축되며, 여러 테이블에 정보를 분산시킬 수 있습니다. 이를 통해 더 복잡한 데이터를 처리하고, 중복을 피하며, 데이터를 탐색하는 방식에 유연성을 제공합니다. 관계형 데이터베이스의 개념을 살펴보겠습니다.

## [강의 전 퀴즈](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/8)

## 모든 것은 테이블에서 시작됩니다

관계형 데이터베이스의 핵심은 테이블입니다. 스프레드시트와 마찬가지로 테이블은 열과 행의 모음입니다. 행은 우리가 작업하려는 데이터나 정보를 포함하며, 예를 들어 도시 이름이나 강수량을 포함할 수 있습니다. 열은 저장된 데이터를 설명합니다.

도시에 대한 정보를 저장하기 위해 테이블을 시작해 봅시다. 도시 이름과 국가를 포함하여 시작할 수 있습니다. 이를 다음과 같은 테이블에 저장할 수 있습니다:

| 도시      | 국가          |
| --------- | ------------- |
| 도쿄      | 일본          |
| 애틀랜타  | 미국          |
| 오클랜드  | 뉴질랜드      |

**도시**, **국가**, **인구**라는 열 이름이 저장된 데이터를 설명하며, 각 행은 한 도시의 정보를 포함하고 있습니다.

## 단일 테이블 접근 방식의 한계

위의 테이블은 비교적 익숙하게 보일 것입니다. 이제 우리의 데이터베이스에 연간 강수량(밀리미터 단위)을 추가해 보겠습니다. 2018년, 2019년, 2020년을 중심으로 살펴보겠습니다. 도쿄에 대해 추가한다면 다음과 같을 것입니다:

| 도시   | 국가   | 연도 | 강수량 |
| ------ | ------ | ---- | ------ |
| 도쿄   | 일본   | 2020 | 1690   |
| 도쿄   | 일본   | 2019 | 1874   |
| 도쿄   | 일본   | 2018 | 1445   |

이 테이블에서 무엇을 발견할 수 있나요? 도시 이름과 국가를 반복적으로 중복 저장하고 있다는 점을 알 수 있습니다. 이는 상당한 저장 공간을 차지할 수 있으며, 불필요한 중복입니다. 결국 도쿄는 우리가 관심 있는 하나의 이름만 가지고 있습니다.

좋습니다, 다른 방법을 시도해 봅시다. 각 연도에 대해 새로운 열을 추가해 보겠습니다:

| 도시      | 국가          | 2018 | 2019 | 2020 |
| --------- | ------------- | ---- | ---- | ---- |
| 도쿄      | 일본          | 1445 | 1874 | 1690 |
| 애틀랜타  | 미국          | 1779 | 1111 | 1683 |
| 오클랜드  | 뉴질랜드      | 1386 | 942  | 1176 |

이 방법은 행 중복을 피할 수 있지만, 몇 가지 다른 문제를 추가합니다. 새로운 연도가 있을 때마다 테이블 구조를 수정해야 합니다. 또한 데이터가 증가함에 따라 연도를 열로 사용하는 것은 값을 검색하고 계산하는 데 어려움을 줄 수 있습니다.

이것이 우리가 여러 테이블과 관계를 필요로 하는 이유입니다. 데이터를 분리함으로써 중복을 피하고 데이터를 처리하는 방식에 더 많은 유연성을 가질 수 있습니다.

## 관계의 개념

데이터로 돌아가서 어떻게 분리할지 결정해 봅시다. 도시 이름과 국가를 저장하고 싶다는 것을 알고 있으므로 이는 하나의 테이블에서 가장 잘 작동할 것입니다.

| 도시      | 국가          |
| --------- | ------------- |
| 도쿄      | 일본          |
| 애틀랜타  | 미국          |
| 오클랜드  | 뉴질랜드      |

하지만 다음 테이블을 만들기 전에 각 도시를 참조하는 방법을 알아내야 합니다. 어떤 형태의 식별자, ID 또는 (기술적 데이터베이스 용어로) 기본 키가 필요합니다. 기본 키는 테이블의 특정 행을 식별하는 데 사용되는 값입니다. 이는 자체 값(예: 도시 이름)을 기반으로 할 수 있지만, 거의 항상 숫자나 다른 식별자여야 합니다. ID가 변경되면 관계가 깨질 수 있기 때문입니다. 대부분의 경우 기본 키 또는 ID는 자동 생성된 숫자가 됩니다.

> ✅ 기본 키는 종종 PK로 약어로 사용됩니다.

### 도시

| city_id | 도시      | 국가          |
| ------- | --------- | ------------- |
| 1       | 도쿄      | 일본          |
| 2       | 애틀랜타  | 미국          |
| 3       | 오클랜드  | 뉴질랜드      |

> ✅ 이 수업 동안 "id"와 "기본 키"라는 용어를 번갈아 사용합니다. 여기서 설명한 개념은 나중에 탐구할 데이터프레임에도 적용됩니다. 데이터프레임은 "기본 키"라는 용어를 사용하지 않지만, 매우 유사한 방식으로 작동한다는 것을 알게 될 것입니다.

도시 테이블을 생성했으니 이제 강수량을 저장해 봅시다. 도시의 전체 정보를 중복 저장하는 대신 ID를 사용할 수 있습니다. 새로 생성된 테이블에도 *id* 열이 있어야 하며, 모든 테이블에는 ID 또는 기본 키가 있어야 합니다.

### 강수량

| rainfall_id | city_id | 연도 | 강수량 |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

새로 생성된 **강수량** 테이블 내부의 **city_id** 열을 주목하세요. 이 열은 **도시** 테이블의 ID를 참조하는 값을 포함합니다. 기술적 관계형 데이터 용어로, 이를 **외래 키**라고 합니다. 이는 다른 테이블의 기본 키입니다. 이를 참조 또는 포인터로 생각할 수 있습니다. **city_id** 1은 도쿄를 참조합니다.

> [!NOTE] 외래 키는 종종 FK로 약어로 사용됩니다.

## 데이터 검색

데이터를 두 개의 테이블로 분리했으니, 데이터를 어떻게 검색할지 궁금할 수 있습니다. MySQL, SQL Server 또는 Oracle과 같은 관계형 데이터베이스를 사용하는 경우 Structured Query Language(SQL)라는 언어를 사용할 수 있습니다. SQL(때로는 시퀄이라고 발음)은 관계형 데이터베이스에서 데이터를 검색하고 수정하는 데 사용되는 표준 언어입니다.

데이터를 검색하려면 `SELECT` 명령을 사용합니다. 기본적으로 **보고 싶은 열을 선택**하고 **그 열이 포함된 테이블에서** 가져옵니다. 도시 이름만 표시하려면 다음을 사용할 수 있습니다:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT`는 열을 나열하는 곳이고, `FROM`은 테이블을 나열하는 곳입니다.

> [NOTE] SQL 구문은 대소문자를 구분하지 않으므로 `select`와 `SELECT`는 동일한 의미를 가집니다. 그러나 사용하는 데이터베이스 유형에 따라 열과 테이블은 대소문자를 구분할 수 있습니다. 따라서 프로그래밍에서 모든 것을 대소문자를 구분하는 것처럼 취급하는 것이 모범 사례입니다. SQL 쿼리를 작성할 때 일반적으로 키워드를 모두 대문자로 작성하는 것이 관례입니다.

위의 쿼리는 모든 도시를 표시합니다. 뉴질랜드에 있는 도시만 표시하고 싶다고 가정해 봅시다. 필터가 필요합니다. SQL 키워드는 `WHERE`이며, "어떤 조건이 참일 때"를 의미합니다.

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## 데이터 결합

지금까지 단일 테이블에서 데이터를 검색했습니다. 이제 **도시**와 **강수량**의 데이터를 결합하고 싶습니다. 이는 *조인*을 통해 이루어집니다. 두 테이블 사이에 연결을 만들고 각 테이블의 열 값을 일치시킵니다.

우리의 예에서는 **강수량**의 **city_id** 열과 **도시**의 **city_id** 열을 일치시킬 것입니다. 이를 통해 강수량 값을 해당 도시와 연결합니다. 우리가 수행할 조인의 유형은 *내부 조인*이라고 하며, 다른 테이블과 일치하지 않는 행은 표시되지 않습니다. 우리의 경우 모든 도시가 강수량 데이터를 가지고 있으므로 모든 것이 표시됩니다.

모든 도시의 2019년 강수량을 검색해 봅시다.

단계를 나누어 진행하겠습니다. 첫 번째 단계는 **city_id** 열을 기준으로 테이블을 조인하는 것입니다.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

조인하려는 두 열과 **city_id**를 기준으로 테이블을 조인하려는 사실을 강조했습니다. 이제 `WHERE` 문을 추가하여 2019년 데이터만 필터링합니다.

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## 요약

관계형 데이터베이스는 정보를 여러 테이블로 나누고 이를 다시 결합하여 표시 및 분석합니다. 이를 통해 계산을 수행하거나 데이터를 조작하는 데 높은 유연성을 제공합니다. 관계형 데이터베이스의 핵심 개념과 두 테이블 간의 조인을 수행하는 방법을 살펴보았습니다.

## 🚀 도전 과제

인터넷에는 수많은 관계형 데이터베이스가 있습니다. 위에서 배운 기술을 사용하여 데이터를 탐색해 보세요.

## 강의 후 퀴즈

## [강의 후 퀴즈](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/9)

## 복습 및 자기 학습

SQL 및 관계형 데이터베이스 개념을 계속 탐구할 수 있는 여러 [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) 리소스가 있습니다.

- [관계형 데이터 개념 설명](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Transact-SQL로 쿼리 시작하기](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL은 SQL의 한 버전입니다)
- [Microsoft Learn의 SQL 콘텐츠](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## 과제

[과제 제목](assignment.md)

**면책 조항**:  
이 문서는 AI 번역 서비스 [Co-op Translator](https://github.com/Azure/co-op-translator)를 사용하여 번역되었습니다. 정확성을 위해 최선을 다하고 있지만, 자동 번역에는 오류나 부정확성이 포함될 수 있습니다. 원본 문서를 해당 언어로 작성된 상태에서 권위 있는 자료로 간주해야 합니다. 중요한 정보의 경우, 전문적인 인간 번역을 권장합니다. 이 번역 사용으로 인해 발생하는 오해나 잘못된 해석에 대해 당사는 책임을 지지 않습니다.