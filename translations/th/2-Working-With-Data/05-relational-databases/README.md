<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80d80300002ef4e77cc7631d5904bd6e",
  "translation_date": "2025-10-25T18:53:33+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "th"
}
-->
# การทำงานกับข้อมูล: ฐานข้อมูลเชิงสัมพันธ์

|![ภาพสเก็ตช์โดย [(@sketchthedocs)](https://sketchthedocs.dev)](../../sketchnotes/05-RelationalData.png)|
|:---:|
| การทำงานกับข้อมูล: ฐานข้อมูลเชิงสัมพันธ์ - _ภาพสเก็ตช์โดย [@nitya](https://twitter.com/nitya)_ |

คุณอาจเคยใช้สเปรดชีตในการจัดเก็บข้อมูลมาก่อน โดยมีชุดของแถวและคอลัมน์ ซึ่งแถวจะมีข้อมูล (หรือข้อมูลที่เราต้องการจัดเก็บ) และคอลัมน์จะอธิบายข้อมูลนั้น (บางครั้งเรียกว่าเมตาดาต้า) ฐานข้อมูลเชิงสัมพันธ์ถูกสร้างขึ้นบนหลักการพื้นฐานนี้ของคอลัมน์และแถวในตาราง ซึ่งช่วยให้คุณสามารถกระจายข้อมูลไปยังหลายตารางได้ สิ่งนี้ช่วยให้คุณทำงานกับข้อมูลที่ซับซ้อนมากขึ้น หลีกเลี่ยงการทำซ้ำ และมีความยืดหยุ่นในการสำรวจข้อมูล ลองมาสำรวจแนวคิดของฐานข้อมูลเชิงสัมพันธ์กัน

## [แบบทดสอบก่อนการบรรยาย](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## ทุกอย่างเริ่มต้นจากตาราง

ฐานข้อมูลเชิงสัมพันธ์มีตารางเป็นแกนหลัก เช่นเดียวกับสเปรดชีต ตารางคือการรวบรวมคอลัมน์และแถว แถวจะมีข้อมูลหรือข้อมูลที่เราต้องการทำงานด้วย เช่น ชื่อเมืองหรือปริมาณน้ำฝน คอลัมน์จะอธิบายข้อมูลที่พวกเขาเก็บไว้

เริ่มต้นการสำรวจของเราด้วยการสร้างตารางเพื่อจัดเก็บข้อมูลเกี่ยวกับเมือง เราอาจเริ่มต้นด้วยชื่อและประเทศของพวกเขา คุณสามารถจัดเก็บข้อมูลนี้ในตารางดังนี้:

| เมือง     | ประเทศ       |
| -------- | ------------- |
| โตเกียว  | ญี่ปุ่น       |
| แอตแลนตา | สหรัฐอเมริกา |
| โอ๊คแลนด์ | นิวซีแลนด์   |

สังเกตชื่อคอลัมน์ **เมือง**, **ประเทศ** และ **ประชากร** ที่อธิบายข้อมูลที่ถูกจัดเก็บ และแต่ละแถวมีข้อมูลเกี่ยวกับหนึ่งเมือง

## ข้อจำกัดของการใช้ตารางเดียว

ตารางด้านบนอาจดูคุ้นเคยสำหรับคุณ ลองเพิ่มข้อมูลเพิ่มเติมในฐานข้อมูลที่กำลังเติบโตของเรา - ปริมาณน้ำฝนรายปี (เป็นมิลลิเมตร) เราจะเน้นที่ปี 2018, 2019 และ 2020 หากเราเพิ่มข้อมูลสำหรับโตเกียว อาจดูเหมือนดังนี้:

| เมือง  | ประเทศ | ปี   | ปริมาณ |
| ----- | ------- | ---- | ------ |
| โตเกียว | ญี่ปุ่น | 2020 | 1690   |
| โตเกียว | ญี่ปุ่น | 2019 | 1874   |
| โตเกียว | ญี่ปุ่น | 2018 | 1445   |

คุณสังเกตอะไรเกี่ยวกับตารางของเรา? คุณอาจสังเกตว่าเรากำลังทำซ้ำชื่อและประเทศของเมืองซ้ำไปซ้ำมา ซึ่งอาจใช้พื้นที่จัดเก็บมาก และไม่จำเป็นต้องมีสำเนาหลายชุด หลังจากทั้งหมด โตเกียวมีเพียงชื่อเดียวที่เราสนใจ

โอเค ลองทำอย่างอื่นดู เรามาเพิ่มคอลัมน์ใหม่สำหรับแต่ละปี:

| เมือง     | ประเทศ       | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| โตเกียว  | ญี่ปุ่น       | 1445 | 1874 | 1690 |
| แอตแลนตา | สหรัฐอเมริกา | 1779 | 1111 | 1683 |
| โอ๊คแลนด์ | นิวซีแลนด์   | 1386 | 942  | 1176 |

แม้ว่าจะหลีกเลี่ยงการทำซ้ำแถว แต่ก็เพิ่มความท้าทายอื่น ๆ เราจะต้องปรับโครงสร้างของตารางทุกครั้งที่มีปีใหม่ นอกจากนี้ เมื่อข้อมูลของเราเพิ่มขึ้น การมีปีเป็นคอลัมน์จะทำให้การดึงและคำนวณค่าต่าง ๆ ยากขึ้น

นี่คือเหตุผลที่เราต้องการตารางหลายตารางและความสัมพันธ์ โดยการแยกข้อมูลออกจากกัน เราสามารถหลีกเลี่ยงการทำซ้ำและมีความยืดหยุ่นมากขึ้นในการทำงานกับข้อมูลของเรา

## แนวคิดของความสัมพันธ์

กลับมาที่ข้อมูลของเราและกำหนดวิธีที่เราต้องการแบ่งข้อมูลออก เรารู้ว่าเราต้องการจัดเก็บชื่อและประเทศของเมือง ดังนั้นสิ่งนี้น่าจะเหมาะสมที่สุดในตารางเดียว

| เมือง     | ประเทศ       |
| -------- | ------------- |
| โตเกียว  | ญี่ปุ่น       |
| แอตแลนตา | สหรัฐอเมริกา |
| โอ๊คแลนด์ | นิวซีแลนด์   |

แต่ก่อนที่เราจะสร้างตารางถัดไป เราต้องหาวิธีอ้างอิงแต่ละเมือง เราต้องการรูปแบบของตัวระบุ, ID หรือ (ในแง่ฐานข้อมูลทางเทคนิค) คีย์หลัก คีย์หลักคือค่าที่ใช้ระบุแถวเฉพาะในตาราง แม้ว่าสิ่งนี้อาจขึ้นอยู่กับค่าตัวเอง (เช่น เราอาจใช้ชื่อเมือง) แต่ควรเป็นตัวเลขหรือตัวระบุอื่น ๆ ที่ไม่ควรเปลี่ยนแปลง เพราะจะทำให้ความสัมพันธ์เสียหายได้ คุณจะพบว่าในกรณีส่วนใหญ่ คีย์หลักหรือ ID จะเป็นตัวเลขที่สร้างขึ้นโดยอัตโนมัติ

> ✅ คีย์หลักมักจะย่อว่า PK

### cities

| city_id | เมือง     | ประเทศ       |
| ------- | -------- | ------------- |
| 1       | โตเกียว  | ญี่ปุ่น       |
| 2       | แอตแลนตา | สหรัฐอเมริกา |
| 3       | โอ๊คแลนด์ | นิวซีแลนด์   |

> ✅ คุณจะสังเกตว่าเราใช้คำว่า "id" และ "คีย์หลัก" สลับกันในบทเรียนนี้ แนวคิดเหล่านี้ใช้กับ DataFrames ซึ่งคุณจะสำรวจในภายหลัง DataFrames ไม่ใช้คำศัพท์ "คีย์หลัก" อย่างไรก็ตาม คุณจะสังเกตว่ามันทำงานในลักษณะเดียวกัน

เมื่อเราสร้างตารางเมืองเสร็จแล้ว ลองจัดเก็บข้อมูลปริมาณน้ำฝนกันดู แทนที่จะทำซ้ำข้อมูลทั้งหมดเกี่ยวกับเมือง เราสามารถใช้ ID ได้ เราควรตรวจสอบให้แน่ใจว่าตารางที่สร้างขึ้นใหม่มีคอลัมน์ *id* ด้วย เนื่องจากทุกตารางควรมี ID หรือคีย์หลัก

### rainfall

| rainfall_id | city_id | ปี   | ปริมาณ |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

สังเกตคอลัมน์ **city_id** ในตาราง **rainfall** ที่สร้างขึ้นใหม่ คอลัมน์นี้มีค่าที่อ้างอิงถึง ID ในตาราง **cities** ในแง่ฐานข้อมูลเชิงสัมพันธ์ทางเทคนิค สิ่งนี้เรียกว่า **คีย์ต่างประเทศ**; มันคือคีย์หลักจากตารางอื่น คุณสามารถคิดว่ามันเป็นการอ้างอิงหรือชี้ไปที่ **city_id** 1 อ้างอิงถึงโตเกียว

> [!NOTE] 
> คีย์ต่างประเทศมักจะย่อว่า FK

## การดึงข้อมูล

เมื่อเราแยกข้อมูลออกเป็นสองตาราง คุณอาจสงสัยว่าเราจะดึงข้อมูลได้อย่างไร หากเราใช้ฐานข้อมูลเชิงสัมพันธ์ เช่น MySQL, SQL Server หรือ Oracle เราสามารถใช้ภาษาที่เรียกว่า Structured Query Language หรือ SQL SQL (บางครั้งออกเสียงว่า "ซีเควล") เป็นภาษามาตรฐานที่ใช้ในการดึงและแก้ไขข้อมูลในฐานข้อมูลเชิงสัมพันธ์

ในการดึงข้อมูล คุณใช้คำสั่ง `SELECT` โดยพื้นฐานแล้วคุณจะ **เลือก** คอลัมน์ที่คุณต้องการดู **จาก** ตารางที่พวกเขาอยู่ หากคุณต้องการแสดงเพียงชื่อเมือง คุณสามารถใช้คำสั่งต่อไปนี้:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` คือที่ที่คุณระบุคอลัมน์ และ `FROM` คือที่ที่คุณระบุตาราง

> [!NOTE] 
> ไวยากรณ์ SQL ไม่แยกแยะตัวพิมพ์ใหญ่และเล็ก หมายความว่า `select` และ `SELECT` มีความหมายเหมือนกัน อย่างไรก็ตาม ขึ้นอยู่กับประเภทของฐานข้อมูลที่คุณใช้งาน คอลัมน์และตารางอาจแยกแยะตัวพิมพ์ใหญ่และเล็ก ดังนั้นจึงเป็นแนวปฏิบัติที่ดีที่สุดที่จะปฏิบัติต่อทุกอย่างในโปรแกรมเหมือนกับว่ามันแยกแยะตัวพิมพ์ใหญ่และเล็ก เมื่อเขียนคำสั่ง SQL ตามธรรมเนียมทั่วไปคือการเขียนคำสำคัญด้วยตัวพิมพ์ใหญ่ทั้งหมด

คำสั่งด้านบนจะแสดงชื่อเมืองทั้งหมด ลองจินตนาการว่าเราต้องการแสดงเฉพาะเมืองในนิวซีแลนด์ เราต้องการรูปแบบของตัวกรอง คำสำคัญ SQL สำหรับสิ่งนี้คือ `WHERE` หรือ "ที่บางสิ่งเป็นจริง"

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## การเชื่อมโยงข้อมูล

จนถึงตอนนี้เราได้ดึงข้อมูลจากตารางเดียว ตอนนี้เราต้องการนำข้อมูลจากทั้ง **cities** และ **rainfall** มารวมกัน สิ่งนี้ทำได้โดยการ *เชื่อมโยง* พวกมันเข้าด้วยกัน คุณจะสร้างการเชื่อมต่อระหว่างสองตาราง และจับคู่ค่าจากคอลัมน์ในแต่ละตาราง

ในตัวอย่างของเรา เราจะจับคู่คอลัมน์ **city_id** ใน **rainfall** กับคอลัมน์ **city_id** ใน **cities** สิ่งนี้จะจับคู่ค่าปริมาณน้ำฝนกับเมืองที่เกี่ยวข้อง ประเภทของการเชื่อมโยงที่เราจะทำคือสิ่งที่เรียกว่า *inner join* หมายความว่าหากแถวใด ๆ ไม่ตรงกับสิ่งใดจากตารางอื่น พวกมันจะไม่ถูกแสดง ในกรณีของเรา ทุกเมืองมีข้อมูลปริมาณน้ำฝน ดังนั้นทุกอย่างจะถูกแสดง

ลองดึงข้อมูลปริมาณน้ำฝนในปี 2019 สำหรับทุกเมืองของเรา

เราจะทำสิ่งนี้เป็นขั้นตอน ขั้นตอนแรกคือการเชื่อมโยงข้อมูลเข้าด้วยกันโดยระบุคอลัมน์สำหรับการเชื่อมต่อ - **city_id** ตามที่เน้นไว้ก่อนหน้านี้

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

เราได้เน้นคอลัมน์สองคอลัมน์ที่เราต้องการ และข้อเท็จจริงที่ว่าเราต้องการเชื่อมโยงตารางเข้าด้วยกันโดยใช้ **city_id** ตอนนี้เราสามารถเพิ่มคำสั่ง `WHERE` เพื่อกรองเฉพาะปี 2019

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## สรุป

ฐานข้อมูลเชิงสัมพันธ์มีศูนย์กลางอยู่ที่การแบ่งข้อมูลระหว่างหลายตาราง ซึ่งจะถูกนำกลับมารวมกันเพื่อแสดงผลและวิเคราะห์ สิ่งนี้ให้ความยืดหยุ่นสูงในการคำนวณและจัดการข้อมูล คุณได้เห็นแนวคิดหลักของฐานข้อมูลเชิงสัมพันธ์ และวิธีการเชื่อมโยงระหว่างสองตาราง

## 🚀 ความท้าทาย

มีฐานข้อมูลเชิงสัมพันธ์มากมายที่สามารถเข้าถึงได้บนอินเทอร์เน็ต คุณสามารถสำรวจข้อมูลโดยใช้ทักษะที่คุณได้เรียนรู้ข้างต้น

## แบบทดสอบหลังการบรรยาย

## [แบบทดสอบหลังการบรรยาย](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## ทบทวนและศึกษาด้วยตนเอง

มีแหล่งข้อมูลหลายแห่งบน [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) ที่คุณสามารถใช้เพื่อสำรวจ SQL และแนวคิดของฐานข้อมูลเชิงสัมพันธ์เพิ่มเติม

- [อธิบายแนวคิดของข้อมูลเชิงสัมพันธ์](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [เริ่มต้นการเขียนคำสั่งด้วย Transact-SQL](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL เป็นเวอร์ชันของ SQL)
- [เนื้อหา SQL บน Microsoft Learn](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## งานที่ได้รับมอบหมาย

[ชื่อหัวข้องาน](assignment.md)

---

**ข้อจำกัดความรับผิดชอบ**:  
เอกสารนี้ได้รับการแปลโดยใช้บริการแปลภาษา AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามให้การแปลมีความถูกต้อง แต่โปรดทราบว่าการแปลโดยอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่ถูกต้อง เอกสารต้นฉบับในภาษาดั้งเดิมควรถือเป็นแหล่งข้อมูลที่เชื่อถือได้ สำหรับข้อมูลที่สำคัญ ขอแนะนำให้ใช้บริการแปลภาษามืออาชีพ เราไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความผิดที่เกิดจากการใช้การแปลนี้