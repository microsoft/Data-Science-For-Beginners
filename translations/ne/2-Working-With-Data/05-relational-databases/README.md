<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80d80300002ef4e77cc7631d5904bd6e",
  "translation_date": "2025-10-25T18:46:00+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "ne"
}
-->
# डाटा संग काम गर्ने: रिलेशनल डाटाबेस

|![ स्केच नोट [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| डाटा संग काम गर्ने: रिलेशनल डाटाबेस - _स्केच नोट [@nitya](https://twitter.com/nitya)_ |

तपाईंले अघिल्लो पटक जानकारी भण्डारण गर्न स्प्रेडशीट प्रयोग गर्नुभएको हुन सक्छ। तपाईंको अगाडि पङ्क्ति र स्तम्भहरूको सेट थियो, जहाँ पङ्क्तिहरूले जानकारी (वा डाटा) समावेश गर्थे, र स्तम्भहरूले जानकारीको वर्णन गर्थे (कहिलेकाहीं मेटाडाटा भनिन्छ)। रिलेशनल डाटाबेस तालिकाहरूमा स्तम्भ र पङ्क्तिहरूको यस कोर सिद्धान्तमा आधारित छ, जसले तपाईंलाई धेरै तालिकाहरूमा जानकारी फैलाउन अनुमति दिन्छ। यसले तपाईंलाई जटिल डाटासँग काम गर्न, दोहोरोपनबाट बच्न, र डाटालाई अन्वेषण गर्ने तरिकामा लचिलोपन प्रदान गर्दछ। आउनुहोस्, रिलेशनल डाटाबेसका अवधारणाहरू अन्वेषण गरौं।

## [पूर्व-व्याख्यान क्विज](https://ff-quizzes.netlify.app/en/ds/quiz/8)

## सबै कुरा तालिकाबाट सुरु हुन्छ

रिलेशनल डाटाबेसको कोरमा तालिकाहरू हुन्छन्। स्प्रेडशीटको जस्तै, तालिका स्तम्भ र पङ्क्तिहरूको संग्रह हो। पङ्क्तिले हामीले काम गर्न चाहेको डाटा वा जानकारी समावेश गर्दछ, जस्तै सहरको नाम वा वर्षा को मात्रा। स्तम्भहरूले तिनीहरूले भण्डारण गर्ने डाटाको वर्णन गर्छन्।

आउनुहोस्, सहरहरूको बारेमा जानकारी भण्डारण गर्न तालिका सुरु गरेर हाम्रो अन्वेषण सुरु गरौं। हामी सहरको नाम र देशबाट सुरु गर्न सक्छौं। तपाईं यसलाई तलको तालिकामा भण्डारण गर्न सक्नुहुन्छ:

| सहर     | देश           |
| -------- | ------------- |
| टोकियो   | जापान         |
| एटलान्टा | संयुक्त राज्य |
| अकल्याण्ड | न्युजिल्याण्ड |

ध्यान दिनुहोस् कि **सहर**, **देश** र **जनसंख्या** स्तम्भका नामहरूले भण्डारण गरिएको डाटाको वर्णन गर्छन्, र प्रत्येक पङ्क्तिमा एक सहरको बारेमा जानकारी छ।

## एकल तालिका दृष्टिकोणको कमी

संभावना छ, माथिको तालिका तपाईंलाई धेरै परिचित लाग्न सक्छ। आउनुहोस्, हाम्रो बढ्दो डाटाबेसमा केही थप डाटा थपौं - वार्षिक वर्षा (मिलिमिटरमा)। हामी २०१८, २०१९ र २०२० वर्षहरूमा ध्यान केन्द्रित गर्नेछौं। यदि हामीले टोकियोको लागि थप्नुपर्‍यो भने, यो केही यस प्रकार देखिन सक्छ:

| सहर  | देश     | वर्ष | मात्रा |
| ----- | ------- | ---- | ------ |
| टोकियो | जापान   | २०२० | १६९०   |
| टोकियो | जापान   | २०१९ | १८७४   |
| टोकियो | जापान   | २०१८ | १४४५   |

हाम्रो तालिकाको बारेमा तपाईंले के देख्नुभयो? तपाईंले देख्न सक्नुहुन्छ कि हामी सहरको नाम र देशलाई बारम्बार दोहोर्याउँदैछौं। यसले धेरै भण्डारण लिन सक्छ, र धेरै हदसम्म अनावश्यक छ। आखिर, टोकियोको लागि हामीलाई चासो भएको केवल एक नाम छ।

ठिक छ, आउनुहोस् केही फरक प्रयास गरौं। प्रत्येक वर्षको लागि नयाँ स्तम्भहरू थपौं:

| सहर     | देश           | २०१८ | २०१९ | २०२० |
| -------- | ------------- | ---- | ---- | ---- |
| टोकियो   | जापान         | १४४५ | १८७४ | १६९० |
| एटलान्टा | संयुक्त राज्य | १७७९ | ११११ | १६८३ |
| अकल्याण्ड | न्युजिल्याण्ड | १३८६ | ९४२  | ११७६ |

यसले पङ्क्ति दोहोरोपनबाट बचाउँछ, तर यसले अन्य चुनौतीहरू थप्छ। प्रत्येक पटक नयाँ वर्ष हुँदा हाम्रो तालिकाको संरचना परिमार्जन गर्न आवश्यक हुनेछ। साथै, हाम्रो डाटा बढ्दै जाँदा, स्तम्भहरूमा वर्षहरू राख्दा मानहरू पुनःप्राप्ति र गणना गर्न गाह्रो हुनेछ।

यही कारणले हामीलाई धेरै तालिकाहरू र सम्बन्धहरू आवश्यक छ। हाम्रो डाटालाई विभाजन गरेर हामी दोहोरोपनबाट बच्न सक्छौं र हाम्रो डाटासँग काम गर्ने तरिकामा बढी लचिलोपन प्राप्त गर्न सक्छौं।

## सम्बन्धहरूको अवधारणाहरू

आउनुहोस्, हाम्रो डाटामा फर्कौं र कसरी यसलाई विभाजन गर्ने भन्ने निर्धारण गरौं। हामीलाई थाहा छ कि सहरहरूको नाम र देश भण्डारण गर्न चाहन्छौं, त्यसैले यो एक तालिकामा राम्रोसँग काम गर्नेछ।

| सहर     | देश           |
| -------- | ------------- |
| टोकियो   | जापान         |
| एटलान्टा | संयुक्त राज्य |
| अकल्याण्ड | न्युजिल्याण्ड |

तर अर्को तालिका सिर्जना गर्नु अघि, हामीले प्रत्येक सहरलाई कसरी सन्दर्भ गर्ने भन्ने पत्ता लगाउन आवश्यक छ। हामीलाई कुनै प्रकारको पहिचानकर्ता, आईडी वा (प्राविधिक डाटाबेस सर्तमा) प्राथमिक कुञ्जी चाहिन्छ। प्राथमिक कुञ्जी एक मान हो जुन तालिकाको एक विशिष्ट पङ्क्ति पहिचान गर्न प्रयोग गरिन्छ। यद्यपि यो आफैंमा आधारित मान हुन सक्छ (उदाहरणका लागि, हामी सहरको नाम प्रयोग गर्न सक्छौं), यो लगभग सधैं एक संख्या वा अन्य पहिचानकर्ता हुनुपर्छ। हामी चाहँदैनौं कि आईडी कहिल्यै परिवर्तन होस् किनकि यसले सम्बन्धलाई तोड्नेछ। तपाईंले अधिकांश अवस्थामा पाउनुहुनेछ कि प्राथमिक कुञ्जी वा आईडी स्वतः उत्पन्न संख्या हुनेछ।

> ✅ प्राथमिक कुञ्जीलाई प्रायः PK भनेर संक्षेपमा उल्लेख गरिन्छ

### सहरहरू

| city_id | सहर     | देश           |
| ------- | -------- | ------------- |
| 1       | टोकियो   | जापान         |
| 2       | एटलान्टा | संयुक्त राज्य |
| 3       | अकल्याण्ड | न्युजिल्याण्ड |

> ✅ तपाईंले देख्नुहुनेछ कि हामीले यस पाठको क्रममा "आईडी" र "प्राथमिक कुञ्जी" शब्दहरू परस्पर प्रयोग गरेका छौं। यहाँका अवधारणाहरू डाटा फ्रेमहरूमा लागू हुन्छन्, जुन तपाईं पछि अन्वेषण गर्नुहुनेछ। डाटा फ्रेमहरूले "प्राथमिक कुञ्जी" को शब्दावली प्रयोग गर्दैनन्, यद्यपि तपाईंले देख्नुहुनेछ कि तिनीहरू धेरै हदसम्म उस्तै व्यवहार गर्छन्।

हाम्रो सहरहरूको तालिका सिर्जना भएपछि, आउनुहोस् वर्षा भण्डारण गरौं। सहरको पूर्ण जानकारी दोहोर्याउने सट्टा, हामी आईडी प्रयोग गर्न सक्छौं। हामीले सुनिश्चित गर्नुपर्छ कि नयाँ सिर्जना गरिएको तालिकामा पनि *आईडी* स्तम्भ छ, किनकि सबै तालिकाहरूमा आईडी वा प्राथमिक कुञ्जी हुनुपर्छ।

### वर्षा

| rainfall_id | city_id | वर्ष | मात्रा |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | २०१८ | १४४५   |
| 2           | 1       | २०१९ | १८७४   |
| 3           | 1       | २०२० | १६९०   |
| 4           | 2       | २०१८ | १७७९   |
| 5           | 2       | २०१९ | ११११   |
| 6           | 2       | २०२० | १६८३   |
| 7           | 3       | २०१८ | १३८६   |
| 8           | 3       | २०१९ | ९४२    |
| 9           | 3       | २०२० | ११७६   |

नयाँ सिर्जना गरिएको **वर्षा** तालिकाको भित्रको **city_id** स्तम्भलाई ध्यान दिनुहोस्। यस स्तम्भमा भएका मानहरूले **सहरहरू** तालिकाको आईडीलाई सन्दर्भ गर्छन्। प्राविधिक रिलेशनल डाटा सर्तमा, यसलाई **विदेशी कुञ्जी** भनिन्छ; यो अर्को तालिकाको प्राथमिक कुञ्जी हो। तपाईं यसलाई सन्दर्भ वा सूचकको रूपमा सोच्न सक्नुहुन्छ। **city_id** 1 टोकियोलाई सन्दर्भ गर्छ।

> [!NOTE] 
> विदेशी कुञ्जीलाई प्रायः FK भनेर संक्षेपमा उल्लेख गरिन्छ

## डाटा पुनःप्राप्ति

हाम्रो डाटालाई दुई तालिकामा विभाजन गरेपछि, तपाईं सोच्न सक्नुहुन्छ कि हामी यसलाई कसरी पुनःप्राप्ति गर्छौं। यदि हामी MySQL, SQL Server वा Oracle जस्ता रिलेशनल डाटाबेस प्रयोग गर्दैछौं भने, हामी Structured Query Language वा SQL नामक भाषा प्रयोग गर्न सक्छौं। SQL (कहिलेकाहीं sequel उच्चारण गरिन्छ) एक मानक भाषा हो जुन रिलेशनल डाटाबेसमा डाटा पुनःप्राप्ति र परिमार्जन गर्न प्रयोग गरिन्छ।

डाटा पुनःप्राप्ति गर्न तपाईंले `SELECT` आदेश प्रयोग गर्नुहुन्छ। यसको कोरमा, तपाईं **select** गर्न चाहनुभएको स्तम्भहरू **from** तालिकाबाट देखाउनुहुन्छ। यदि तपाईंले केवल सहरहरूको नाम देखाउन चाहनुभयो भने, तपाईंले निम्न प्रयोग गर्न सक्नुहुन्छ:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` जहाँ तपाईं स्तम्भहरूको सूची बनाउनुहुन्छ, र `FROM` जहाँ तपाईं तालिकाहरूको सूची बनाउनुहुन्छ।

> [!NOTE] 
> SQL सिन्ट्याक्स केस-इन्सेन्सेटिभ हो, जसको अर्थ `select` र `SELECT` उस्तै हो। यद्यपि, तपाईंले प्रयोग गरिरहेको डाटाबेसको प्रकारमा निर्भर गर्दै स्तम्भहरू र तालिकाहरू केस-सेंसिटिभ हुन सक्छ। परिणामस्वरूप, प्रोग्रामिङमा सबै कुरा केस-सेंसिटिभ जस्तो व्यवहार गर्ने राम्रो अभ्यास हो। SQL क्वेरीहरू लेख्दा सामान्य परम्परा भनेको सबै कीवर्डहरूलाई ठूला अक्षरमा लेख्नु हो।

माथिको क्वेरीले सबै सहरहरू देखाउनेछ। आउनुहोस्, कल्पना गरौं कि हामीले केवल न्युजिल्याण्डका सहरहरू देखाउन चाह्यौं। हामीलाई कुनै प्रकारको फिल्टर चाहिन्छ। SQL कीवर्ड यसको लागि `WHERE` हो, वा "जहाँ केही सत्य छ"।

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## डाटा जोड्ने

अहिलेसम्म हामीले एकल तालिकाबाट डाटा पुनःप्राप्ति गरेका छौं। अब हामीले **सहरहरू** र **वर्षा** दुवैबाट डाटालाई सँगै ल्याउन चाहन्छौं। यो तिनीहरूलाई *जोडेर* गरिन्छ। तपाईंले प्रभावकारी रूपमा दुई तालिकाहरू बीचको सीम सिर्जना गर्नुहुनेछ, र प्रत्येक तालिकाको स्तम्भबाट मानहरू मिलाउनुहुनेछ।

हाम्रो उदाहरणमा, हामी **rainfall** मा रहेको **city_id** स्तम्भलाई **cities** मा रहेको **city_id** स्तम्भसँग मिलाउनेछौं। यसले वर्षाको मानलाई यसको सम्बन्धित सहरसँग मिलाउनेछ। हामीले गर्ने जोड *भित्री* जोड हो, जसको अर्थ कुनै पनि पङ्क्तिहरू अर्को तालिकाबाट कुनै पनि चीजसँग मेल खाँदैन भने तिनीहरू देखाइने छैनन्। हाम्रो केसमा प्रत्येक सहरसँग वर्षा छ, त्यसैले सबै देखाइनेछ।

आउनुहोस्, २०१९ को वर्षाको डाटा सबै सहरहरूको लागि पुनःप्राप्ति गरौं।

हामी यो चरणहरूमा गर्नेछौं। पहिलो चरण भनेको **city_id** स्तम्भलाई हाइलाइट गरेर तालिकाहरूलाई सँगै जोड्नु हो।

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

हामीले चाहेको दुई स्तम्भहरू र **city_id** द्वारा तालिकाहरूलाई सँगै जोड्न चाहेको तथ्यलाई हाइलाइट गरेका छौं। अब हामीले `WHERE` स्टेटमेन्ट थपेर केवल २०१९ वर्षलाई फिल्टर गर्न सक्छौं।

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## सारांश

रिलेशनल डाटाबेसहरू धेरै तालिकाहरू बीच जानकारी विभाजनमा केन्द्रित छन्, जुन प्रदर्शन र विश्लेषणको लागि सँगै ल्याइन्छ। यसले गणना गर्न र अन्यथा डाटालाई हेरफेर गर्न उच्च स्तरको लचिलोपन प्रदान गर्दछ। तपाईंले रिलेशनल डाटाबेसका कोर अवधारणाहरू देख्नुभएको छ, र दुई तालिकाहरू बीचको जोड कसरी गर्ने भनेर सिक्नुभएको छ।

## 🚀 चुनौती

इन्टरनेटमा धेरै रिलेशनल डाटाबेसहरू उपलब्ध छन्। तपाईंले माथि सिकेका सीपहरू प्रयोग गरेर डाटालाई अन्वेषण गर्न सक्नुहुन्छ।

## व्याख्यानपछिको क्विज

## [व्याख्यानपछिको क्विज](https://ff-quizzes.netlify.app/en/ds/quiz/9)

## समीक्षा र आत्म-अध्ययन

SQL र रिलेशनल डाटाबेस अवधारणाहरूको अन्वेषण जारी राख्नको लागि [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) मा धेरै स्रोतहरू उपलब्ध छन्।

- [रिलेशनल डाटाको अवधारणाहरू वर्णन गर्नुहोस्](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [Transact-SQL संग क्वेरी गर्न सुरु गर्नुहोस्](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL SQL को एक संस्करण हो)
- [Microsoft Learn मा SQL सामग्री](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## असाइनमेन्ट

[असाइनमेन्ट शीर्षक](assignment.md)

---

**अस्वीकरण**:  
यो दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) प्रयोग गरेर अनुवाद गरिएको छ। हामी शुद्धताको लागि प्रयास गर्छौं, तर कृपया ध्यान दिनुहोस् कि स्वचालित अनुवादहरूमा त्रुटिहरू वा अशुद्धताहरू हुन सक्छ। यसको मूल भाषा मा रहेको मूल दस्तावेज़लाई आधिकारिक स्रोत मानिनुपर्छ। महत्वपूर्ण जानकारीको लागि, व्यावसायिक मानव अनुवाद सिफारिस गरिन्छ। यस अनुवादको प्रयोगबाट उत्पन्न हुने कुनै पनि गलतफहमी वा गलत व्याख्याको लागि हामी जिम्मेवार हुनेछैनौं।