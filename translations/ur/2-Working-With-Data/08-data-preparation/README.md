<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "1b560955ff39a2bcf2a049fce474a951",
  "translation_date": "2025-09-06T06:38:44+00:00",
  "source_file": "2-Working-With-Data/08-data-preparation/README.md",
  "language_code": "ur"
}
-->
# ڈیٹا کے ساتھ کام کرنا: ڈیٹا کی تیاری

|![ [(@sketchthedocs)](https://sketchthedocs.dev) کی طرف سے اسکیچ نوٹ ](../../sketchnotes/08-DataPreparation.png)|
|:---:|
|ڈیٹا کی تیاری - _[@nitya](https://twitter.com/nitya) کی طرف سے اسکیچ نوٹ_ |

## [لیکچر سے پہلے کا کوئز](https://ff-quizzes.netlify.app/en/ds/quiz/14)

ڈیٹا کے ماخذ کے مطابق، خام ڈیٹا میں کچھ تضادات ہو سکتے ہیں جو تجزیہ اور ماڈلنگ میں مشکلات پیدا کریں گے۔ دوسرے الفاظ میں، اس ڈیٹا کو "گندا" کہا جا سکتا ہے اور اسے صاف کرنے کی ضرورت ہوگی۔ یہ سبق ڈیٹا کو صاف کرنے اور تبدیل کرنے کی تکنیکوں پر توجہ مرکوز کرتا ہے تاکہ گمشدہ، غلط، یا نامکمل ڈیٹا کے چیلنجز سے نمٹا جا سکے۔ اس سبق میں شامل موضوعات Python اور Pandas لائبریری کا استعمال کریں گے اور اس ڈائریکٹری میں موجود [نوٹ بک میں مظاہرہ کیا جائے گا](../../../../2-Working-With-Data/08-data-preparation/notebook.ipynb)۔

## ڈیٹا صاف کرنے کی اہمیت

- **استعمال اور دوبارہ استعمال میں آسانی**: جب ڈیٹا مناسب طریقے سے منظم اور نارملائز کیا جاتا ہے تو اسے تلاش کرنا، استعمال کرنا، اور دوسروں کے ساتھ شیئر کرنا آسان ہو جاتا ہے۔

- **مطابقت**: ڈیٹا سائنس اکثر ایک سے زیادہ ڈیٹا سیٹس کے ساتھ کام کرنے کی ضرورت ہوتی ہے، جہاں مختلف ذرائع سے ڈیٹا سیٹس کو ایک ساتھ جوڑنا پڑتا ہے۔ یہ یقینی بنانا کہ ہر انفرادی ڈیٹا سیٹ میں عام معیاری کاری ہو، اس بات کو یقینی بنائے گا کہ جب وہ سب ایک ڈیٹا سیٹ میں ضم ہو جائیں تو ڈیٹا اب بھی مفید رہے۔

- **ماڈل کی درستگی**: صاف کیا گیا ڈیٹا ان ماڈلز کی درستگی کو بہتر بناتا ہے جو اس پر انحصار کرتے ہیں۔

## عام صفائی کے اہداف اور حکمت عملیاں

- **ڈیٹا سیٹ کا جائزہ لینا**: ڈیٹا کا جائزہ لینا، جو [بعد کے سبق](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/4-Data-Science-Lifecycle/15-analyzing) میں شامل ہے، آپ کو وہ ڈیٹا دریافت کرنے میں مدد دے سکتا ہے جسے صاف کرنے کی ضرورت ہے۔ ڈیٹا سیٹ میں موجود اقدار کو بصری طور پر دیکھنا توقعات قائم کر سکتا ہے کہ باقی ڈیٹا کیسا نظر آئے گا، یا ان مسائل کا اندازہ دے سکتا ہے جنہیں حل کیا جا سکتا ہے۔ جائزہ لینے میں بنیادی سوالات، بصریات، اور نمونے شامل ہو سکتے ہیں۔

- **فارمیٹنگ**: ماخذ کے مطابق، ڈیٹا کی پیشکش میں تضادات ہو سکتے ہیں۔ یہ تلاش کرنے اور قدر کی نمائندگی کرنے میں مسائل پیدا کر سکتا ہے، جہاں یہ ڈیٹا سیٹ میں دیکھا جاتا ہے لیکن بصریات یا سوالات کے نتائج میں مناسب طریقے سے ظاہر نہیں ہوتا۔ عام فارمیٹنگ کے مسائل میں سفید جگہ، تاریخیں، اور ڈیٹا کی اقسام کو حل کرنا شامل ہے۔ فارمیٹنگ کے مسائل کو حل کرنا عام طور پر ان لوگوں پر منحصر ہوتا ہے جو ڈیٹا استعمال کر رہے ہیں۔ مثال کے طور پر، تاریخوں اور نمبروں کی پیشکش کے معیارات ملک کے لحاظ سے مختلف ہو سکتے ہیں۔

- **تکرار**: ڈیٹا جس میں ایک سے زیادہ وقوع پذیر ہو، غلط نتائج پیدا کر سکتا ہے اور عام طور پر اسے ہٹا دینا چاہیے۔ یہ عام طور پر اس وقت ہوتا ہے جب دو یا زیادہ ڈیٹا سیٹس کو ایک ساتھ جوڑا جاتا ہے۔ تاہم، ایسے مواقع بھی ہوتے ہیں جہاں جوڑے گئے ڈیٹا سیٹس میں تکرار اضافی معلومات فراہم کر سکتی ہے اور اسے محفوظ رکھنے کی ضرورت ہو سکتی ہے۔

- **گمشدہ ڈیٹا**: گمشدہ ڈیٹا غلطیوں کے ساتھ ساتھ کمزور یا متعصب نتائج کا سبب بن سکتا ہے۔ کبھی کبھی ان مسائل کو ڈیٹا کو دوبارہ لوڈ کرنے، گمشدہ اقدار کو حساب اور کوڈ جیسے Python کے ذریعے بھرنے، یا صرف قدر اور متعلقہ ڈیٹا کو ہٹانے سے حل کیا جا سکتا ہے۔ ڈیٹا کے گم ہونے کی وجوہات مختلف ہو سکتی ہیں اور ان گمشدہ اقدار کو حل کرنے کے لیے کیے گئے اقدامات اس بات پر منحصر ہو سکتے ہیں کہ وہ کیسے اور کیوں گم ہوئے۔

## ڈیٹا فریم کی معلومات کا جائزہ لینا
> **سیکھنے کا مقصد:** اس ذیلی حصے کے اختتام تک، آپ کو pandas ڈیٹا فریمز میں ذخیرہ شدہ ڈیٹا کے بارے میں عمومی معلومات تلاش کرنے میں مہارت حاصل ہو جانی چاہیے۔

جب آپ نے اپنا ڈیٹا pandas میں لوڈ کر لیا ہو، تو یہ زیادہ تر امکان ہے کہ یہ ایک ڈیٹا فریم میں ہوگا (تفصیلی جائزہ کے لیے [پچھلے سبق](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/2-Working-With-Data/07-python#dataframe) کا حوالہ دیں)۔ تاہم، اگر آپ کے ڈیٹا فریم میں 60,000 قطاریں اور 400 کالم ہیں، تو آپ یہ سمجھنا کیسے شروع کریں گے کہ آپ کس کے ساتھ کام کر رہے ہیں؟ خوش قسمتی سے، [pandas](https://pandas.pydata.org/) ڈیٹا فریم کے بارے میں مجموعی معلومات کو جلدی سے دیکھنے کے لیے کچھ آسان ٹولز فراہم کرتا ہے، اس کے علاوہ پہلی چند اور آخری چند قطاریں بھی۔

اس فعالیت کو دریافت کرنے کے لیے، ہم Python scikit-learn لائبریری کو درآمد کریں گے اور ایک مشہور ڈیٹا سیٹ استعمال کریں گے: **Iris ڈیٹا سیٹ**۔

```python
import pandas as pd
from sklearn.datasets import load_iris

iris = load_iris()
iris_df = pd.DataFrame(data=iris['data'], columns=iris['feature_names'])
```
|                                        |sepal length (cm)|sepal width (cm)|petal length (cm)|petal width (cm)|
|----------------------------------------|-----------------|----------------|-----------------|----------------|
|0                                       |5.1              |3.5             |1.4              |0.2             |
|1                                       |4.9              |3.0             |1.4              |0.2             |
|2                                       |4.7              |3.2             |1.3              |0.2             |
|3                                       |4.6              |3.1             |1.5              |0.2             |
|4                                       |5.0              |3.6             |1.4              |0.2             |

- **DataFrame.info**: شروع کرنے کے لیے، `info()` طریقہ استعمال کیا جاتا ہے تاکہ `DataFrame` میں موجود مواد کا خلاصہ پرنٹ کیا جا سکے۔ آئیے اس ڈیٹا سیٹ کو دیکھتے ہیں کہ ہمارے پاس کیا ہے:
```python
iris_df.info()
```
```
RangeIndex: 150 entries, 0 to 149
Data columns (total 4 columns):
 #   Column             Non-Null Count  Dtype  
---  ------             --------------  -----  
 0   sepal length (cm)  150 non-null    float64
 1   sepal width (cm)   150 non-null    float64
 2   petal length (cm)  150 non-null    float64
 3   petal width (cm)   150 non-null    float64
dtypes: float64(4)
memory usage: 4.8 KB
```
اس سے ہمیں معلوم ہوتا ہے کہ *Iris* ڈیٹا سیٹ میں چار کالموں میں 150 اندراجات ہیں جن میں کوئی null اندراج نہیں ہے۔ تمام ڈیٹا 64-bit floating-point نمبروں کے طور پر ذخیرہ کیا گیا ہے۔

- **DataFrame.head()**: اگلا، `DataFrame` کے اصل مواد کو چیک کرنے کے لیے، ہم `head()` طریقہ استعمال کرتے ہیں۔ آئیے دیکھتے ہیں کہ ہمارے `iris_df` کی پہلی چند قطاریں کیسی نظر آتی ہیں:
```python
iris_df.head()
```
```
   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0                5.1               3.5                1.4               0.2
1                4.9               3.0                1.4               0.2
2                4.7               3.2                1.3               0.2
3                4.6               3.1                1.5               0.2
4                5.0               3.6                1.4               0.2
```
- **DataFrame.tail()**: اس کے برعکس، `DataFrame` کی آخری چند قطاروں کو چیک کرنے کے لیے، ہم `tail()` طریقہ استعمال کرتے ہیں:
```python
iris_df.tail()
```
```
     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
145                6.7               3.0                5.2               2.3
146                6.3               2.5                5.0               1.9
147                6.5               3.0                5.2               2.0
148                6.2               3.4                5.4               2.3
149                5.9               3.0                5.1               1.8
```
> **نتیجہ:** صرف ڈیٹا فریم میں موجود معلومات کے میٹا ڈیٹا کو دیکھ کر یا اس میں موجود پہلی اور آخری چند اقدار کو دیکھ کر، آپ فوری طور پر اس ڈیٹا کے سائز، شکل، اور مواد کے بارے میں ایک اندازہ لگا سکتے ہیں جس کے ساتھ آپ کام کر رہے ہیں۔

## گمشدہ ڈیٹا سے نمٹنا
> **سیکھنے کا مقصد:** اس ذیلی حصے کے اختتام تک، آپ کو ڈیٹا فریمز سے null اقدار کو تبدیل یا ہٹانے کا طریقہ معلوم ہو جانا چاہیے۔

زیادہ تر وقت، وہ ڈیٹا سیٹس جنہیں آپ استعمال کرنا چاہتے ہیں (یا استعمال کرنا پڑتا ہے) ان میں گمشدہ اقدار ہوتی ہیں۔ گمشدہ ڈیٹا کو سنبھالنے کے ساتھ کچھ باریک تجارتی معاہدے ہوتے ہیں جو آپ کے حتمی تجزیے اور حقیقی دنیا کے نتائج کو متاثر کر سکتے ہیں۔

Pandas گمشدہ اقدار کو دو طریقوں سے سنبھالتا ہے۔ پہلا آپ نے پہلے سیکشنز میں دیکھا ہے: `NaN`، یا Not a Number۔ یہ دراصل ایک خاص قدر ہے جو IEEE floating-point وضاحت کا حصہ ہے اور یہ صرف گمشدہ floating-point اقدار کی نشاندہی کرنے کے لیے استعمال ہوتی ہے۔

floating-point کے علاوہ گمشدہ اقدار کے لیے، pandas Python کے `None` object کا استعمال کرتا ہے۔ اگرچہ یہ الجھن پیدا کر سکتا ہے کہ آپ کو دو مختلف قسم کی اقدار کا سامنا کرنا پڑے گا جو بنیادی طور پر ایک ہی بات کہتے ہیں، اس ڈیزائن انتخاب کے پیچھے مضبوط پروگرامنگ وجوہات ہیں اور، عملی طور پر، اس راستے پر جانے سے pandas زیادہ تر معاملات کے لیے ایک اچھا سمجھوتہ فراہم کرتا ہے۔ اس کے باوجود، `None` اور `NaN` دونوں پابندیاں رکھتے ہیں جن کے بارے میں آپ کو محتاط رہنے کی ضرورت ہے کہ انہیں کیسے استعمال کیا جا سکتا ہے۔

`NaN` اور `None` کے بارے میں مزید جاننے کے لیے [نوٹ بک](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/4-Data-Science-Lifecycle/15-analyzing/notebook.ipynb) دیکھیں!

- **null اقدار کا پتہ لگانا**: `pandas` میں، `isnull()` اور `notnull()` طریقے null ڈیٹا کا پتہ لگانے کے لیے آپ کے بنیادی طریقے ہیں۔ دونوں آپ کے ڈیٹا پر Boolean masks واپس کرتے ہیں۔ ہم `numpy` کو `NaN` اقدار کے لیے استعمال کریں گے:
```python
import numpy as np

example1 = pd.Series([0, np.nan, '', None])
example1.isnull()
```
```
0    False
1     True
2    False
3     True
dtype: bool
```
آؤٹ پٹ کو غور سے دیکھیں۔ کیا اس میں سے کوئی چیز آپ کو حیران کرتی ہے؟ اگرچہ `0` ایک arithmetic null ہے، یہ پھر بھی ایک بالکل درست integer ہے اور pandas اسے اسی طرح سمجھتا ہے۔ `''` تھوڑا زیادہ پیچیدہ ہے۔ اگرچہ ہم نے اسے سیکشن 1 میں ایک خالی string قدر کی نمائندگی کے لیے استعمال کیا، یہ پھر بھی ایک string object ہے اور pandas کے لحاظ سے null کی نمائندگی نہیں ہے۔

اب، آئیے اسے الٹ دیں اور ان طریقوں کو اس انداز میں استعمال کریں جیسے آپ انہیں عملی طور پر استعمال کریں گے۔ آپ Boolean masks کو براہ راست ایک ``Series`` یا ``DataFrame`` انڈیکس کے طور پر استعمال کر سکتے ہیں، جو گمشدہ (یا موجود) اقدار کے ساتھ الگ تھلگ کام کرنے کی کوشش کرتے وقت مفید ہو سکتا ہے۔

> **نتیجہ:** `isnull()` اور `notnull()` دونوں طریقے `DataFrame`s میں استعمال کرتے وقت ملتے جلتے نتائج پیدا کرتے ہیں: وہ نتائج اور ان نتائج کے انڈیکس کو دکھاتے ہیں، جو آپ کے ڈیٹا کے ساتھ کام کرتے وقت آپ کے لیے بے حد مددگار ثابت ہوں گے۔

- **null اقدار کو ہٹانا**: null اقدار کی شناخت کے علاوہ، pandas `Series` اور `DataFrame`s سے null اقدار کو ہٹانے کا ایک آسان ذریعہ فراہم کرتا ہے۔ (خاص طور پر بڑے ڈیٹا سیٹس پر، تجزیے سے گمشدہ [NA] اقدار کو ہٹانا اکثر زیادہ مشورہ دیا جاتا ہے بجائے اس کے کہ انہیں دوسرے طریقوں سے نمٹا جائے۔) اس کو عملی طور پر دیکھنے کے لیے، آئیے `example1` پر واپس جائیں:
```python
example1 = example1.dropna()
example1
```
```
0    0
2     
dtype: object
```
نوٹ کریں کہ یہ آپ کے آؤٹ پٹ کی طرح نظر آنا چاہیے `example3[example3.notnull()]`۔ یہاں فرق یہ ہے کہ، masked اقدار پر صرف انڈیکسنگ کرنے کے بجائے، `dropna` نے `Series` `example1` سے ان گمشدہ اقدار کو ہٹا دیا ہے۔

چونکہ `DataFrame`s کے دو ابعاد ہوتے ہیں، وہ ڈیٹا کو ہٹانے کے لیے مزید اختیارات فراہم کرتے ہیں۔

```python
example2 = pd.DataFrame([[1,      np.nan, 7], 
                         [2,      5,      8], 
                         [np.nan, 6,      9]])
example2
```
|      | 0 | 1 | 2 |
|------|---|---|---|
|0     |1.0|NaN|7  |
|1     |2.0|5.0|8  |
|2     |NaN|6.0|9  |

(کیا آپ نے دیکھا کہ pandas نے دو کالموں کو floats میں تبدیل کر دیا تاکہ `NaN`s کو ایڈجسٹ کیا جا سکے؟)

آپ `DataFrame` سے ایک واحد قدر کو ہٹا نہیں سکتے، لہذا آپ کو مکمل قطاریں یا کالم ہٹانے ہوں گے۔ اس پر منحصر ہے کہ آپ کیا کر رہے ہیں، آپ ایک یا دوسرے کو ہٹانا چاہیں گے، اور اس لیے pandas آپ کو دونوں کے لیے اختیارات دیتا ہے۔ چونکہ ڈیٹا سائنس میں، کالم عام طور پر متغیرات کی نمائندگی کرتے ہیں اور قطاریں مشاہدات کی نمائندگی کرتی ہیں، آپ زیادہ امکان رکھتے ہیں کہ ڈیٹا کی قطاریں ہٹائیں؛ `dropna()` کے لیے ڈیفالٹ سیٹنگ یہ ہے کہ تمام قطاریں ہٹا دیں جو کسی بھی null اقدار پر مشتمل ہوں:

```python
example2.dropna()
```
```
	0	1	2
1	2.0	5.0	8
```
اگر ضروری ہو، تو آپ کالمز سے NA اقدار کو ہٹا سکتے ہیں۔ ایسا کرنے کے لیے `axis=1` استعمال کریں:
```python
example2.dropna(axis='columns')
```
```
	2
0	7
1	8
2	9
```
نوٹ کریں کہ یہ بہت زیادہ ڈیٹا ہٹا سکتا ہے جسے آپ رکھنا چاہتے ہیں، خاص طور پر چھوٹے ڈیٹا سیٹس میں۔ اگر آپ صرف ان قطاروں یا کالمز کو ہٹانا چاہتے ہیں جو کئی یا یہاں تک کہ تمام null اقدار پر مشتمل ہوں؟ آپ `dropna` میں `how` اور `thresh` پیرامیٹرز کے ساتھ ان ترتیبات کی وضاحت کرتے ہیں۔

ڈیفالٹ کے طور پر، `how='any'` (اگر آپ خود چیک کرنا چاہتے ہیں یا دیکھنا چاہتے ہیں کہ اس طریقے کے دوسرے پیرامیٹرز کیا ہیں، تو کوڈ سیل میں `example4.dropna?` چلائیں)۔ آپ متبادل طور پر `how='all'` کی وضاحت کر سکتے ہیں تاکہ صرف ان قطاروں یا کالمز کو ہٹایا جا سکے جو تمام null اقدار پر مشتمل ہوں۔ آئیے ہمارے مثال `DataFrame` کو بڑھاتے ہیں تاکہ اسے عملی طور پر دیکھ سکیں۔

```python
example2[3] = np.nan
example2
```
|      |0  |1  |2  |3  |
|------|---|---|---|---|
|0     |1.0|NaN|7  |NaN|
|1     |2.0|5.0|8  |NaN|
|2     |NaN|6.0|9  |NaN|

`thresh` پیرامیٹر آپ کو زیادہ باریک کنٹرول دیتا ہے: آپ ان قطاروں یا کالمز کی تعداد مقرر کرتے ہیں جنہیں برقرار رکھنے کے لیے *non-null* اقدار کی ضرورت ہوتی ہے:
```python
example2.dropna(axis='rows', thresh=3)
```
```
	0	1	2	3
1	2.0	5.0	8	NaN
```
یہاں، پہلی اور آخری قطاریں ہٹا دی گئی ہیں، کیونکہ ان میں صرف دو non-null اقدار ہیں۔

- **null اقدار کو بھرنا**: آپ کے ڈیٹا سیٹ پر منحصر ہے، کبھی کبھی null اقدار کو درست اقدار سے بھرنا زیادہ معنی خیز ہو سکتا ہے بجائے اس کے کہ انہیں ہٹا دیا جائے۔ آپ `isnull` کو جگہ میں ایسا کرنے کے لیے استعمال کر سکتے ہیں، لیکن یہ محنت طلب ہو سکتا ہے، خاص طور پر اگر آپ کے پاس بھرنے کے لیے بہت سی اقدار ہوں۔ چونکہ یہ ڈیٹا سائنس میں ایک عام کام ہے، pandas `fillna` فراہم کرتا ہے، جو `Series` یا `DataFrame` کی ایک کاپی واپس کرتا ہے جس میں گمشدہ اقدار کو آپ کی پسند کی کسی ایک سے تبدیل کیا گیا ہو۔ آئیے ایک اور مثال `Series` بنائیں تاکہ یہ عملی طور پر کیسے کام کرتا ہے دیکھ سکیں۔
```python
example3 = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))
example3
```
```
a    1.0
b    NaN
c    2.0
d    NaN
e    3.0
dtype: float64
```
آپ تمام null اندراجات کو ایک واحد قدر، جیسے `0` سے بھر سکتے ہیں:
```python
example3.fillna(0)
```
```
a    1.0
b    0.0
c    2.0
d    0.0
e    3.0
dtype: float64
```
آپ null اقدار کو **آگے بھر** سکتے ہیں، یعنی آخری درست قدر کو null بھرنے کے لیے استعمال کریں:
```python
example3.fillna(method='ffill')
```
```
a    1.0
b    1.0
c    2.0
d    2.0
e    3.0
dtype: float64
```
آپ null کو بھرنے کے لیے اگلی درست قدر کو پیچھے کی طرف **واپس بھر** سکتے ہیں:
```python
example3.fillna(method='bfill')
```
```
a    1.0
b    2.0
c    2.0
d    3.0
e    3.0
dtype: float64
```
جیسا کہ آپ اندازہ لگا سکتے ہیں، یہ `DataFrame`s کے ساتھ بھی اسی طرح کام کرتا ہے، لیکن آپ null اقدار کو بھرنے کے لیے ایک `axis` بھی مخصوص کر سکتے ہیں۔ پہلے استعمال شدہ `example2` کو دوبارہ لیں:
```python
example2.fillna(method='ffill', axis=1)
```
```
	0	1	2	3
0	1.0	1.0	7.0	7.0
1	2.0	5.0	8.0	8.0
2	NaN	6.0	9.0	9.0
```
نوٹ کریں کہ جب پچھلی قدر آگے بھرنے کے لیے دستیاب نہیں ہوتی، تو null قدر برقرار رہتی ہے۔
> **خلاصہ:** آپ کے ڈیٹاسیٹس میں موجود گمشدہ اقدار سے نمٹنے کے کئی طریقے ہیں۔ جو خاص حکمت عملی آپ اپناتے ہیں (انہیں ہٹانا، تبدیل کرنا، یا یہاں تک کہ کیسے تبدیل کرنا) وہ ڈیٹا کی خصوصیات پر منحصر ہونا چاہیے۔ جتنا زیادہ آپ ڈیٹاسیٹس کے ساتھ کام کریں گے اور ان کے ساتھ تعامل کریں گے، گمشدہ اقدار سے نمٹنے کا بہتر طریقہ سمجھنے میں مدد ملے گی۔
## ڈپلیکیٹ ڈیٹا کو ہٹانا

> **سیکھنے کا مقصد:** اس حصے کے اختتام تک، آپ کو ڈیٹا فریمز سے ڈپلیکیٹ ویلیوز کی شناخت اور انہیں ہٹانے میں مہارت حاصل ہو جانی چاہیے۔

گمشدہ ڈیٹا کے علاوہ، آپ کو حقیقی دنیا کے ڈیٹا سیٹس میں اکثر ڈپلیکیٹ ڈیٹا کا سامنا کرنا پڑے گا۔ خوش قسمتی سے، `pandas` ڈپلیکیٹ اندراجات کی شناخت اور انہیں ہٹانے کے لیے ایک آسان طریقہ فراہم کرتا ہے۔

- **ڈپلیکیٹ کی شناخت: `duplicated`**: آپ `pandas` میں `duplicated` میتھڈ کا استعمال کرتے ہوئے آسانی سے ڈپلیکیٹ ویلیوز کو پہچان سکتے ہیں، جو ایک Boolean ماسک واپس کرتا ہے جو یہ ظاہر کرتا ہے کہ آیا `DataFrame` میں کوئی اندراج پہلے والے کا ڈپلیکیٹ ہے۔ آئیے ایک اور مثال کے طور پر `DataFrame` بناتے ہیں تاکہ اسے عملی طور پر دیکھ سکیں۔
```python
example4 = pd.DataFrame({'letters': ['A','B'] * 2 + ['B'],
                         'numbers': [1, 2, 1, 3, 3]})
example4
```
|      |letters|numbers|
|------|-------|-------|
|0     |A      |1      |
|1     |B      |2      |
|2     |A      |1      |
|3     |B      |3      |
|4     |B      |3      |

```python
example4.duplicated()
```
```
0    False
1    False
2     True
3    False
4     True
dtype: bool
```
- **ڈپلیکیٹ کو ہٹانا: `drop_duplicates`:** یہ صرف ان ڈیٹا کی ایک کاپی واپس کرتا ہے جن کے تمام `duplicated` ویلیوز `False` ہیں:
```python
example4.drop_duplicates()
```
```
	letters	numbers
0	A	1
1	B	2
3	B	3
```
`duplicated` اور `drop_duplicates` دونوں ڈیفالٹ طور پر تمام کالمز کو مدنظر رکھتے ہیں، لیکن آپ یہ وضاحت کر سکتے ہیں کہ وہ آپ کے `DataFrame` میں صرف ایک مخصوص کالمز کے سیٹ کا جائزہ لیں:
```python
example4.drop_duplicates(['letters'])
```
```
letters	numbers
0	A	1
1	B	2
```

> **نتیجہ:** ڈپلیکیٹ ڈیٹا کو ہٹانا تقریباً ہر ڈیٹا سائنس پروجیکٹ کا ایک لازمی حصہ ہے۔ ڈپلیکیٹ ڈیٹا آپ کے تجزیے کے نتائج کو تبدیل کر سکتا ہے اور آپ کو غلط نتائج دے سکتا ہے!


## 🚀 چیلنج

تمام زیر بحث مواد [Jupyter Notebook](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/2-Working-With-Data/08-data-preparation/notebook.ipynb) کی شکل میں فراہم کیے گئے ہیں۔ اس کے علاوہ، ہر سیکشن کے بعد مشقیں موجود ہیں، انہیں آزما کر دیکھیں!

## [لیکچر کے بعد کا کوئز](https://ff-quizzes.netlify.app/en/ds/quiz/15)



## جائزہ اور خود مطالعہ

اپنے ڈیٹا کو تجزیہ اور ماڈلنگ کے لیے تیار کرنے کے کئی طریقے ہیں، اور ڈیٹا کو صاف کرنا ایک اہم قدم ہے جو عملی تجربے کا تقاضا کرتا ہے۔ Kaggle کے ان چیلنجز کو آزمائیں تاکہ ان تکنیکوں کو دریافت کریں جنہیں اس سبق میں شامل نہیں کیا گیا۔

- [ڈیٹا صاف کرنے کا چیلنج: تاریخوں کو پارس کرنا](https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/)

- [ڈیٹا صاف کرنے کا چیلنج: ڈیٹا کو اسکیل اور نارملائز کرنا](https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data)


## اسائنمنٹ

[فارم سے ڈیٹا کا جائزہ لینا](assignment.md)

---

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا غیر درستیاں ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ ہم اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے ذمہ دار نہیں ہیں۔